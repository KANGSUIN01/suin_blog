{
  
    
        "post0": {
            "title": "Numpy 기본",
            "content": "도구 - 넘파이(NumPy) . *넘파이(NumPy)는 파이썬의 과학 컴퓨팅을 위한 기본 라이브러리입니다. 넘파이의 핵심은 강력한 N-차원 배열 객체입니다. 또한 선형 대수, 푸리에(Fourier) 변환, 유사 난수 생성과 같은 유용한 함수들도 제공합니다.&quot; . 구글 코랩에서 실행하기 | &#48176;&#50676; &#49373;&#49457; . numpy를 임포트해 보죠. 대부분의 사람들이 np로 알리아싱하여 임포트합니다: . import numpy as np . np.zeros . zeros 함수는 0으로 채워진 배열을 만듭니다: . np.zeros(5) . array([0., 0., 0., 0., 0.]) . 2D 배열(즉, 행렬)을 만들려면 원하는 행과 열의 크기를 튜플로 전달합니다. 예를 들어 다음은 $3 times 4$ 크기의 행렬입니다: . np.zeros((3,4)) . array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) . &#50857;&#50612; . 넘파이에서 각 차원을 축(axis) 이라고 합니다 | 축의 개수를 랭크(rank) 라고 합니다. 예를 들어, 위의 $3 times 4$ 행렬은 랭크 2인 배열입니다(즉 2차원입니다). | 첫 번째 축의 길이는 3이고 두 번째 축의 길이는 4입니다. | . | 배열의 축 길이를 배열의 크기(shape)라고 합니다. 예를 들어, 위 행렬의 크기는 (3, 4)입니다. | 랭크는 크기의 길이와 같습니다. | . | 배열의 사이즈(size)는 전체 원소의 개수입니다. 축의 길이를 모두 곱해서 구할 수 있습니다(가령, $3 times 4=12$). | . a = np.zeros((3,4)) a . array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) . a.shape . (3, 4) . a.ndim # len(a.shape)와 같습니다 . 2 . a.size . 12 . N-&#52264;&#50896; &#48176;&#50676; . 임의의 랭크 수를 가진 N-차원 배열을 만들 수 있습니다. 예를 들어, 다음은 크기가 (2,3,4)인 3D 배열(랭크=3)입니다: . np.zeros((2,2,5)) . array([[[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]], [[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]]]) . &#48176;&#50676; &#53440;&#51077; . 넘파이 배열의 타입은 ndarray입니다: . type(np.zeros((3,4))) . numpy.ndarray . np.ones . ndarray를 만들 수 있는 넘파이 함수가 많습니다. . 다음은 1로 채워진 $3 times 4$ 크기의 행렬입니다: . np.ones((3,4)) . array([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]) . np.full . 주어진 값으로 지정된 크기의 배열을 초기화합니다. 다음은 π로 채워진 $3 times 4$ 크기의 행렬입니다. . np.full((3,4), np.pi) . array([[3.14159265, 3.14159265, 3.14159265, 3.14159265], [3.14159265, 3.14159265, 3.14159265, 3.14159265], [3.14159265, 3.14159265, 3.14159265, 3.14159265]]) . np.empty . 초기화되지 않은 $2 times 3$ 크기의 배열을 만듭니다(배열의 내용은 예측이 불가능하며 메모리 상황에 따라 달라집니다): . np.empty((2,3)) . array([[9.6677106e-317, 0.0000000e+000, 0.0000000e+000], [0.0000000e+000, 0.0000000e+000, 0.0000000e+000]]) . np.array . array 함수는 파이썬 리스트를 사용하여 ndarray를 초기화합니다: . np.array([[1,2,3,4], [10, 20, 30, 40]]) . array([[ 1, 2, 3, 4], [10, 20, 30, 40]]) . np.arange . 파이썬의 기본 range 함수와 비슷한 넘파이 arange 함수를 사용하여 ndarray를 만들 수 있습니다: . np.arange(1, 5) . array([1, 2, 3, 4]) . 부동 소수도 가능합니다: . np.arange(1.0, 5.0) . array([1., 2., 3., 4.]) . 파이썬의 기본 range 함수처럼 건너 뛰는 정도를 지정할 수 있습니다: . np.arange(1, 5, 0.5) . array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5]) . 부동 소수를 사용하면 원소의 개수가 일정하지 않을 수 있습니다. 예를 들면 다음과 같습니다: . print(np.arange(0, 5/3, 1/3)) # 부동 소수 오차 때문에, 최댓값은 4/3 또는 5/3이 됩니다. print(np.arange(0, 5/3, 0.333333333)) print(np.arange(0, 5/3, 0.333333334)) . [0. 0.33333333 0.66666667 1. 1.33333333 1.66666667] [0. 0.33333333 0.66666667 1. 1.33333333 1.66666667] [0. 0.33333333 0.66666667 1. 1.33333334] . np.linspace . 이런 이유로 부동 소수를 사용할 땐 arange 대신에 linspace 함수를 사용하는 것이 좋습니다. linspace 함수는 지정된 개수만큼 두 값 사이를 나눈 배열을 반환합니다(arange와는 다르게 최댓값이 포함됩니다): . print(np.linspace(0, 5/3, 6)) . [0. 0.33333333 0.66666667 1. 1.33333333 1.66666667] . np.rand&#50752; np.randn . 넘파이의 random 모듈에는 ndarray를 랜덤한 값으로 초기화할 수 있는 함수들이 많이 있습니다. 예를 들어, 다음은 (균등 분포인) 0과 1사이의 랜덤한 부동 소수로 $3 times 4$ 행렬을 초기화합니다: . np.random.rand(3,4) . array([[0.37892456, 0.17966937, 0.38206837, 0.34922123], [0.80462136, 0.9845914 , 0.9416127 , 0.28305275], [0.21201033, 0.54891417, 0.03781613, 0.4369229 ]]) . 다음은 평균이 0이고 분산이 1인 일변량 정규 분포(가우시안 분포)에서 샘플링한 랜덤한 부동 소수를 담은 $3 times 4$ 행렬입니다: . np.random.randn(3,4) . array([[ 0.83811287, -0.57131751, -0.4381827 , 1.1485899 ], [ 1.45316084, -0.47259181, -1.23426057, -0.0669813 ], [ 1.01003549, 1.04381736, -0.93060038, 2.39043293]]) . 이 분포의 모양을 알려면 맷플롯립을 사용해 그려보는 것이 좋습니다(더 자세한 것은 맷플롯립 튜토리얼을 참고하세요): . %matplotlib inline import matplotlib.pyplot as plt . plt.hist(np.random.rand(100000), density=True, bins=100, histtype=&quot;step&quot;, color=&quot;blue&quot;, label=&quot;rand&quot;) plt.hist(np.random.randn(100000), density=True, bins=100, histtype=&quot;step&quot;, color=&quot;red&quot;, label=&quot;randn&quot;) plt.axis([-2.5, 2.5, 0, 1.1]) plt.legend(loc = &quot;upper left&quot;) plt.title(&quot;Random distributions&quot;) plt.xlabel(&quot;Value&quot;) plt.ylabel(&quot;Density&quot;) plt.show() . np.fromfunction . 함수를 사용하여 ndarray를 초기화할 수도 있습니다: . def my_function(z, y, x): return x + 10 * y + 100 * z np.fromfunction(my_function, (3, 2, 10)) . array([[[ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9.], [ 10., 11., 12., 13., 14., 15., 16., 17., 18., 19.]], [[100., 101., 102., 103., 104., 105., 106., 107., 108., 109.], [110., 111., 112., 113., 114., 115., 116., 117., 118., 119.]], [[200., 201., 202., 203., 204., 205., 206., 207., 208., 209.], [210., 211., 212., 213., 214., 215., 216., 217., 218., 219.]]]) . 넘파이는 먼저 크기가 (3, 2, 10)인 세 개의 ndarray(차원마다 하나씩)를 만듭니다. 각 배열은 축을 따라 좌표 값과 같은 값을 가집니다. 예를 들어, z 축에 있는 배열의 모든 원소는 z-축의 값과 같습니다: . [[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] [[ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] [ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] [[ 2. 2. 2. 2. 2. 2. 2. 2. 2. 2.] [ 2. 2. 2. 2. 2. 2. 2. 2. 2. 2.]]] . 위의 식 x + 10 * y + 100 * z에서 x, y, z는 사실 ndarray입니다(배열의 산술 연산에 대해서는 아래에서 설명합니다). 중요한 점은 함수 my_function이 원소마다 호출되는 것이 아니고 딱 한 번 호출된다는 점입니다. 그래서 매우 효율적으로 초기화할 수 있습니다. . &#48176;&#50676; &#45936;&#51060;&#53552; . dtype . 넘파이의 ndarray는 모든 원소가 동일한 타입(보통 숫자)을 가지기 때문에 효율적입니다. dtype 속성으로 쉽게 데이터 타입을 확인할 수 있습니다: . c = np.arange(1, 5) print(c.dtype, c) . int64 [1 2 3 4] . c = np.arange(1.0, 5.0) print(c.dtype, c) . float64 [1. 2. 3. 4.] . 넘파이가 데이터 타입을 결정하도록 내버려 두는 대신 dtype 매개변수를 사용해서 배열을 만들 때 명시적으로 지정할 수 있습니다: . d = np.arange(1, 5, dtype=np.complex64) print(d.dtype, d) . complex64 [1.+0.j 2.+0.j 3.+0.j 4.+0.j] . 가능한 데이터 타입은 int8, int16, int32, int64, uint8|16|32|64, float16|32|64, complex64|128가 있습니다. 전체 리스트는 온라인 문서를 참고하세요. . itemsize . itemsize 속성은 각 아이템의 크기(바이트)를 반환합니다: . e = np.arange(1, 5, dtype=np.complex64) e.itemsize . 8 . data &#48260;&#54140; . 배열의 데이터는 1차원 바이트 버퍼로 메모리에 저장됩니다. data 속성을 사용해 참조할 수 있습니다(사용할 일은 거의 없겠지만요). . f = np.array([[1,2],[1000, 2000]], dtype=np.int32) f.data . &lt;memory at 0x7f97929dd790&gt; . 파이썬 2에서는 f.data가 버퍼이고 파이썬 3에서는 memoryview입니다. . if (hasattr(f.data, &quot;tobytes&quot;)): data_bytes = f.data.tobytes() # python 3 else: data_bytes = memoryview(f.data).tobytes() # python 2 data_bytes . b&#39; x01 x00 x00 x00 x02 x00 x00 x00 xe8 x03 x00 x00 xd0 x07 x00 x00&#39; . 여러 개의 ndarray가 데이터 버퍼를 공유할 수 있습니다. 하나를 수정하면 다른 것도 바뀝니다. 잠시 후에 예를 살펴 보겠습니다. . &#48176;&#50676; &#53356;&#44592; &#48320;&#44221; . &#51088;&#49888;&#51012; &#48320;&#44221; . ndarray의 shape 속성을 지정하면 간단히 크기를 바꿀 수 있습니다. 배열의 원소 개수는 동일하게 유지됩니다. . g = np.arange(24) print(g) print(&quot;랭크:&quot;, g.ndim) . [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23] 랭크: 1 . g.shape = (6, 4) print(g) print(&quot;랭크:&quot;, g.ndim) . [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19] [20 21 22 23]] 랭크: 2 . g.shape = (2, 3, 4) print(g) print(&quot;랭크:&quot;, g.ndim) . [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] 랭크: 3 . reshape . reshape 함수는 동일한 데이터를 가리키는 새로운 ndarray 객체를 반환합니다. 한 배열을 수정하면 다른 것도 함께 바뀝니다. . g2 = g.reshape(4,6) print(g2) print(&quot;랭크:&quot;, g2.ndim) . [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] 랭크: 2 . 행 1, 열 2의 원소를 999로 설정합니다(인덱싱 방식은 아래를 참고하세요). . g2[1, 2] = 999 g2 . array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 999, 9, 10, 11], [ 12, 13, 14, 15, 16, 17], [ 18, 19, 20, 21, 22, 23]]) . 이에 상응하는 g의 원소도 수정됩니다. . g . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [999, 9, 10, 11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23]]]) . ravel . 마지막으로 ravel 함수는 동일한 데이터를 가리키는 새로운 1차원 ndarray를 반환합니다: . g.ravel() . array([ 0, 1, 2, 3, 4, 5, 6, 7, 999, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . &#49328;&#49696; &#50672;&#49328; . 일반적인 산술 연산자(+, -, *, /, //, ** 등)는 모두 ndarray와 사용할 수 있습니다. 이 연산자는 원소별로 적용됩니다: . a = np.array([14, 23, 32, 41]) b = np.array([5, 4, 3, 2]) print(&quot;a + b =&quot;, a + b) print(&quot;a - b =&quot;, a - b) print(&quot;a * b =&quot;, a * b) print(&quot;a / b =&quot;, a / b) print(&quot;a // b =&quot;, a // b) print(&quot;a % b =&quot;, a % b) print(&quot;a ** b =&quot;, a ** b) . a + b = [19 27 35 43] a - b = [ 9 19 29 39] a * b = [70 92 96 82] a / b = [ 2.8 5.75 10.66666667 20.5 ] a // b = [ 2 5 10 20] a % b = [4 3 2 1] a ** b = [537824 279841 32768 1681] . 여기 곱셈은 행렬 곱셈이 아닙니다. 행렬 연산은 아래에서 설명합니다. . 배열의 크기는 같아야 합니다. 그렇지 않으면 넘파이가 브로드캐스팅 규칙을 적용합니다. . &#48652;&#47196;&#46300;&#52880;&#49828;&#54021; . 일반적으로 넘파이는 동일한 크기의 배열을 기대합니다. 그렇지 않은 상황에는 브로드캐시틍 규칙을 적용합니다: . &#44508;&#52825; 1 . 배열의 랭크가 동일하지 않으면 랭크가 맞을 때까지 랭크가 작은 배열 앞에 1을 추가합니다. . h = np.arange(5).reshape(1, 1, 5) h . array([[[0, 1, 2, 3, 4]]]) . 여기에 (1,1,5) 크기의 3D 배열에 (5,) 크기의 1D 배열을 더해 보죠. 브로드캐스팅의 규칙 1이 적용됩니다! . h + [10, 20, 30, 40, 50] # 다음과 동일합니다: h + [[[10, 20, 30, 40, 50]]] . array([[[10, 21, 32, 43, 54]]]) . &#44508;&#52825; 2 . 특정 차원이 1인 배열은 그 차원에서 크기가 가장 큰 배열의 크기에 맞춰 동작합니다. 배열의 원소가 차원을 따라 반복됩니다. . k = np.arange(6).reshape(2, 3) k . array([[0, 1, 2], [3, 4, 5]]) . (2,3) 크기의 2D ndarray에 (2,1) 크기의 2D 배열을 더해 보죠. 넘파이는 브로드캐스팅 규칙 2를 적용합니다: . k + [[100], [200]] # 다음과 같습니다: k + [[100, 100, 100], [200, 200, 200]] . array([[100, 101, 102], [203, 204, 205]]) . 규칙 1과 2를 합치면 다음과 같이 동작합니다: . k + [100, 200, 300] # 규칙 1 적용: [[100, 200, 300]], 규칙 2 적용: [[100, 200, 300], [100, 200, 300]] . array([[100, 201, 302], [103, 204, 305]]) . 또 매우 간단히 다음 처럼 해도 됩니다: . k + 1000 # 다음과 같습니다: k + [[1000, 1000, 1000], [1000, 1000, 1000]] . array([[1000, 1001, 1002], [1003, 1004, 1005]]) . &#44508;&#52825; 3 . 규칙 1 &amp; 2을 적용했을 때 모든 배열의 크기가 맞아야 합니다. . try: k + [33, 44] except ValueError as e: print(e) . operands could not be broadcast together with shapes (2,3) (2,) . 브로드캐스팅 규칙은 산술 연산 뿐만 아니라 넘파이 연산에서 많이 사용됩니다. 아래에서 더 보도록 하죠. 브로드캐스팅에 관한 더 자세한 정보는 온라인 문서를 참고하세요. . &#50629;&#52880;&#49828;&#54021; . dtype이 다른 배열을 합칠 때 넘파이는 (실제 값에 상관없이) 모든 값을 다룰 수 있는 타입으로 업캐스팅합니다. . k1 = np.arange(0, 5, dtype=np.uint8) print(k1.dtype, k1) . uint8 [0 1 2 3 4] . k2 = k1 + np.array([5, 6, 7, 8, 9], dtype=np.int8) print(k2.dtype, k2) . int16 [ 5 7 9 11 13] . 모든 int8과 uint8 값(-128에서 255까지)을 표현하기 위해 int16이 필요합니다. 이 코드에서는 uint8이면 충분하지만 업캐스팅되었습니다. . k3 = k1 + 1.5 print(k3.dtype, k3) . float64 [1.5 2.5 3.5 4.5 5.5] . &#51312;&#44148; &#50672;&#49328;&#51088; . 조건 연산자도 원소별로 적용됩니다: . m = np.array([20, -5, 30, 40]) m &lt; [15, 16, 35, 36] . array([False, True, True, False]) . 브로드캐스팅을 사용합니다: . m &lt; 25 # m &lt; [25, 25, 25, 25] 와 동일 . array([ True, True, False, False]) . 불리언 인덱싱과 함께 사용하면 아주 유용합니다(아래에서 설명하겠습니다). . m[m &lt; 25] . array([20, -5]) . &#49688;&#54617; &#54632;&#49688;&#50752; &#53685;&#44228; &#54632;&#49688; . ndarray에서 사용할 수 있는 수학 함수와 통계 함수가 많습니다. . ndarray &#47700;&#49436;&#46300; . 일부 함수는 ndarray 메서드로 제공됩니다. 예를 들면: . a = np.array([[-2.5, 3.1, 7], [10, 11, 12]]) print(a) print(&quot;평균 =&quot;, a.mean()) . [[-2.5 3.1 7. ] [10. 11. 12. ]] 평균 = 6.766666666666667 . 이 명령은 크기에 상관없이 ndarray에 있는 모든 원소의 평균을 계산합니다. . 다음은 유용한 ndarray 메서드입니다: . for func in (a.min, a.max, a.sum, a.prod, a.std, a.var): print(func.__name__, &quot;=&quot;, func()) . min = -2.5 max = 12.0 sum = 40.6 prod = -71610.0 std = 5.084835843520964 var = 25.855555555555554 . 이 함수들은 선택적으로 매개변수 axis를 사용합니다. 지정된 축을 따라 원소에 연산을 적용하는데 사용합니다. 예를 들면: . c=np.arange(24).reshape(2,3,4) c . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) . c.sum(axis=0) # 첫 번째 축을 따라 더함, 결과는 3x4 배열 . array([[12, 14, 16, 18], [20, 22, 24, 26], [28, 30, 32, 34]]) . c.sum(axis=1) # 두 번째 축을 따라 더함, 결과는 2x4 배열 . array([[12, 15, 18, 21], [48, 51, 54, 57]]) . 여러 축에 대해서 더할 수도 있습니다: . c.sum(axis=(0,2)) # 첫 번째 축과 세 번째 축을 따라 더함, 결과는 (3,) 배열 . array([ 60, 92, 124]) . 0+1+2+3 + 12+13+14+15, 4+5+6+7 + 16+17+18+19, 8+9+10+11 + 20+21+22+23 . (60, 92, 124) . &#51068;&#48152; &#54632;&#49688; . 넘파이는 일반 함수(universal function) 또는 ufunc라고 부르는 원소별 함수를 제공합니다. 예를 들면 square 함수는 원본 ndarray를 복사하여 각 원소를 제곱한 새로운 ndarray 객체를 반환합니다: . a = np.array([[-2.5, 3.1, 7], [10, 11, 12]]) np.square(a) . array([[ 6.25, 9.61, 49. ], [100. , 121. , 144. ]]) . 다음은 유용한 단항 일반 함수들입니다: . print(&quot;원본 ndarray&quot;) print(a) for func in (np.abs, np.sqrt, np.exp, np.log, np.sign, np.ceil, np.modf, np.isnan, np.cos): print(&quot; n&quot;, func.__name__) print(func(a)) . 원본 ndarray [[-2.5 3.1 7. ] [10. 11. 12. ]] absolute [[ 2.5 3.1 7. ] [10. 11. 12. ]] sqrt [[ nan 1.76068169 2.64575131] [3.16227766 3.31662479 3.46410162]] exp [[8.20849986e-02 2.21979513e+01 1.09663316e+03] [2.20264658e+04 5.98741417e+04 1.62754791e+05]] log [[ nan 1.13140211 1.94591015] [2.30258509 2.39789527 2.48490665]] sign [[-1. 1. 1.] [ 1. 1. 1.]] ceil [[-2. 4. 7.] [10. 11. 12.]] modf (array([[-0.5, 0.1, 0. ], [ 0. , 0. , 0. ]]), array([[-2., 3., 7.], [10., 11., 12.]])) isnan [[False False False] [False False False]] cos [[-0.80114362 -0.99913515 0.75390225] [-0.83907153 0.0044257 0.84385396]] . &lt;ipython-input-59-d791c8e37e6f&gt;:5: RuntimeWarning: invalid value encountered in sqrt print(func(a)) &lt;ipython-input-59-d791c8e37e6f&gt;:5: RuntimeWarning: invalid value encountered in log print(func(a)) . &#51060;&#54637; &#51068;&#48152; &#54632;&#49688; . 두 개의 ndarray에 원소별로 적용되는 이항 함수도 많습니다. 두 배열이 동일한 크기가 아니면 브로드캐스팅 규칙이 적용됩니다: . a = np.array([1, -2, 3, 4]) b = np.array([2, 8, -1, 7]) np.add(a, b) # a + b 와 동일 . array([ 3, 6, 2, 11]) . np.greater(a, b) # a &gt; b 와 동일 . array([False, False, True, False]) . np.maximum(a, b) . array([2, 8, 3, 7]) . np.copysign(a, b) . array([ 1., 2., -3., 4.]) . &#48176;&#50676; &#51064;&#45937;&#49905; . 1&#52264;&#50896; &#48176;&#50676; . 1차원 넘파이 배열은 보통의 파이썬 배열과 비슷하게 사용할 수 있습니다: . a = np.array([1, 5, 3, 19, 13, 7, 3]) a[3] . 19 . a[2:5] . array([ 3, 19, 13]) . a[2:-1] . array([ 3, 19, 13, 7]) . a[:2] . array([1, 5]) . a[2::2] . array([ 3, 13, 3]) . a[::-1] . array([ 3, 7, 13, 19, 3, 5, 1]) . 물론 원소를 수정할 수 있죠: . a[3]=999 a . array([ 1, 5, 3, 999, 13, 7, 3]) . 슬라이싱을 사용해 ndarray를 수정할 수 있습니다: . a[2:5] = [997, 998, 999] a . array([ 1, 5, 997, 998, 999, 7, 3]) . &#48372;&#53685;&#51032; &#54028;&#51060;&#50028; &#48176;&#50676;&#44284; &#52264;&#51060;&#51216; . 보통의 파이썬 배열과 대조적으로 ndarray 슬라이싱에 하나의 값을 할당하면 슬라이싱 전체에 복사됩니다. 위에서 언급한 브로드캐스팅 덕택입니다. . a[2:5] = -1 a . array([ 1, 5, -1, -1, -1, 7, 3]) . 또한 이런 식으로 ndarray 크기를 늘리거나 줄일 수 없습니다: . try: a[2:5] = [1,2,3,4,5,6] # 너무 길어요 except ValueError as e: print(e) . cannot copy sequence with size 6 to array axis with dimension 3 . 원소를 삭제할 수도 없습니다: . try: del a[2:5] except ValueError as e: print(e) . cannot delete array elements . 중요한 점은 ndarray의 슬라이싱은 같은 데이터 버퍼를 바라보는 뷰(view)입니다. 슬라이싱된 객체를 수정하면 실제 원본 ndarray가 수정됩니다! . a_slice = a[2:6] a_slice[1] = 1000 a # 원본 배열이 수정됩니다! . array([ 1, 5, -1, 1000, -1, 7, 3]) . a[3] = 2000 a_slice # 비슷하게 원본 배열을 수정하면 슬라이싱 객체에도 반영됩니다! . array([ -1, 2000, -1, 7]) . 데이터를 복사하려면 copy 메서드를 사용해야 합니다: . another_slice = a[2:6].copy() another_slice[1] = 3000 a # 원본 배열이 수정되지 않습니다 . array([ 1, 5, -1, 2000, -1, 7, 3]) . a[3] = 4000 another_slice # 마찬가지로 원본 배열을 수정해도 복사된 배열은 바뀌지 않습니다 . array([ -1, 3000, -1, 7]) . &#45796;&#52264;&#50896; &#48176;&#50676; . 다차원 배열은 비슷한 방식으로 각 축을 따라 인덱싱 또는 슬라이싱해서 사용합니다. 콤마로 구분합니다: . b = np.arange(48).reshape(4, 12) b . array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]]) . b[1, 2] # 행 1, 열 2 . 14 . b[1, :] # 행 1, 모든 열 . array([12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . b[:, 1] # 모든 행, 열 1 . array([ 1, 13, 25, 37]) . 주의: 다음 두 표현에는 미묘한 차이가 있습니다: . b[1, :] . array([12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . b[1:2, :] . array([[12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]]) . 첫 번째 표현식은 (12,) 크기인 1D 배열로 행이 하나입니다. 두 번째는 (1, 12) 크기인 2D 배열로 같은 행을 반환합니다. . &#54060;&#49884; &#51064;&#45937;&#49905;(Fancy indexing) . 관심 대상의 인덱스 리스트를 지정할 수도 있습니다. 이를 팬시 인덱싱이라고 부릅니다. . b[(0,2), 2:5] # 행 0과 2, 열 2에서 4(5-1)까지 . array([[ 2, 3, 4], [26, 27, 28]]) . b[:, (-1, 2, -1)] # 모든 행, 열 -1 (마지막), 2와 -1 (다시 반대 방향으로) . array([[11, 2, 11], [23, 14, 23], [35, 26, 35], [47, 38, 47]]) . 여러 개의 인덱스 리스트를 지정하면 인덱스에 맞는 값이 포함된 1D ndarray를 반환됩니다. . b[(-1, 2, -1, 2), (5, 9, 1, 9)] # returns a 1D array with b[-1, 5], b[2, 9], b[-1, 1] and b[2, 9] (again) . array([41, 33, 37, 33]) . &#44256;&#52264;&#50896; . 고차원에서도 동일한 방식이 적용됩니다. 몇 가지 예를 살펴 보겠습니다: . c = b.reshape(4,2,6) c . array([[[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]], [[12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]], [[24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35]], [[36, 37, 38, 39, 40, 41], [42, 43, 44, 45, 46, 47]]]) . c[2, 1, 4] # 행렬 2, 행 1, 열 4 . 34 . c[2, :, 3] # 행렬 2, 모든 행, 열 3 . array([27, 33]) . 어떤 축에 대한 인덱스를 지정하지 않으면 이 축의 모든 원소가 반환됩니다: . c[2, 1] # 행렬 2, 행 1, 모든 열이 반환됩니다. c[2, 1, :]와 동일합니다. . array([30, 31, 32, 33, 34, 35]) . &#49373;&#47029; &#48512;&#54840; (...) . 생략 부호(...)를 쓰면 모든 지정하지 않은 축의 원소를 포함합니다. . c[2, ...] # 행렬 2, 모든 행, 모든 열. c[2, :, :]와 동일 . array([[24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35]]) . c[2, 1, ...] # 행렬 2, 행 1, 모든 열. c[2, 1, :]와 동일 . array([30, 31, 32, 33, 34, 35]) . c[2, ..., 3] # 행렬 2, 모든 행, 열 3. c[2, :, 3]와 동일 . array([27, 33]) . c[..., 3] # 모든 행렬, 모든 행, 열 3. c[:, :, 3]와 동일 . array([[ 3, 9], [15, 21], [27, 33], [39, 45]]) . &#48520;&#47532;&#50616; &#51064;&#45937;&#49905; . 불리언 값을 가진 ndarray를 사용해 축의 인덱스를 지정할 수 있습니다. . b = np.arange(48).reshape(4, 12) b . array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]]) . rows_on = np.array([True, False, True, False]) b[rows_on, :] # 행 0과 2, 모든 열. b[(0, 2), :]와 동일 . array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]]) . cols_on = np.array([False, True, False] * 4) b[:, cols_on] # 모든 행, 열 1, 4, 7, 10 . array([[ 1, 4, 7, 10], [13, 16, 19, 22], [25, 28, 31, 34], [37, 40, 43, 46]]) . np.ix_ . 여러 축에 걸쳐서는 불리언 인덱싱을 사용할 수 없고 ix_ 함수를 사용합니다: . b[np.ix_(rows_on, cols_on)] . array([[ 1, 4, 7, 10], [25, 28, 31, 34]]) . np.ix_(rows_on, cols_on) . (array([[0], [2]]), array([[ 1, 4, 7, 10]])) . ndarray와 같은 크기의 불리언 배열을 사용하면 해당 위치가 True인 모든 원소를 담은 1D 배열이 반환됩니다. 일반적으로 조건 연산자와 함께 사용합니다: . b[b % 3 == 1] . array([ 1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46]) . &#48152;&#48373; . ndarray를 반복하는 것은 일반적인 파이썬 배열을 반복한는 것과 매우 유사합니다. 다차원 배열을 반복하면 첫 번째 축에 대해서 수행됩니다. . c = np.arange(24).reshape(2, 3, 4) # 3D 배열 (두 개의 3x4 행렬로 구성됨) c . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) . for m in c: print(&quot;아이템:&quot;) print(m) . 아이템: [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] 아이템: [[12 13 14 15] [16 17 18 19] [20 21 22 23]] . for i in range(len(c)): # len(c) == c.shape[0] print(&quot;아이템:&quot;) print(c[i]) . 아이템: [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] 아이템: [[12 13 14 15] [16 17 18 19] [20 21 22 23]] . ndarray에 있는 모든 원소를 반복하려면 flat 속성을 사용합니다: . for i in c.flat: print(&quot;아이템:&quot;, i) . 아이템: 0 아이템: 1 아이템: 2 아이템: 3 아이템: 4 아이템: 5 아이템: 6 아이템: 7 아이템: 8 아이템: 9 아이템: 10 아이템: 11 아이템: 12 아이템: 13 아이템: 14 아이템: 15 아이템: 16 아이템: 17 아이템: 18 아이템: 19 아이템: 20 아이템: 21 아이템: 22 아이템: 23 . &#48176;&#50676; &#49939;&#44592; . 종종 다른 배열을 쌓아야 할 때가 있습니다. 넘파이는 이를 위해 몇 개의 함수를 제공합니다. 먼저 배열 몇 개를 만들어 보죠. . q1 = np.full((3,4), 1.0) q1 . array([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]) . q2 = np.full((4,4), 2.0) q2 . array([[2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.]]) . q3 = np.full((3,4), 3.0) q3 . array([[3., 3., 3., 3.], [3., 3., 3., 3.], [3., 3., 3., 3.]]) . vstack . vstack 함수를 사용하여 수직으로 쌓아보죠: . q4 = np.vstack((q1, q2, q3)) q4 . array([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [3., 3., 3., 3.], [3., 3., 3., 3.], [3., 3., 3., 3.]]) . q4.shape . (10, 4) . q1, q2, q3가 모두 같은 크기이므로 가능합니다(수직으로 쌓기 때문에 수직 축은 크기가 달라도 됩니다). . hstack . hstack을 사용해 수평으로도 쌓을 수 있습니다: . q5 = np.hstack((q1, q3)) q5 . array([[1., 1., 1., 1., 3., 3., 3., 3.], [1., 1., 1., 1., 3., 3., 3., 3.], [1., 1., 1., 1., 3., 3., 3., 3.]]) . q5.shape . (3, 8) . q1과 q3가 모두 3개의 행을 가지고 있기 때문에 가능합니다. q2는 4개의 행을 가지고 있기 때문에 q1, q3와 수평으로 쌓을 수 없습니다: . try: q5 = np.hstack((q1, q2, q3)) except ValueError as e: print(e) . all the input array dimensions for the concatenation axis must match exactly, but along dimension 0, the array at index 0 has size 3 and the array at index 1 has size 4 . concatenate . concatenate 함수는 지정한 축으로도 배열을 쌓습니다. . q7 = np.concatenate((q1, q2, q3), axis=0) # vstack과 동일 q7 . array([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [3., 3., 3., 3.], [3., 3., 3., 3.], [3., 3., 3., 3.]]) . q7.shape . (10, 4) . 예상했겠지만 hstack은 axis=1으로 concatenate를 호출하는 것과 같습니다. . stack . stack 함수는 새로운 축을 따라 배열을 쌓습니다. 모든 배열은 같은 크기를 가져야 합니다. . q8 = np.stack((q1, q3)) q8 . array([[[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]], [[3., 3., 3., 3.], [3., 3., 3., 3.], [3., 3., 3., 3.]]]) . q8.shape . (2, 3, 4) . &#48176;&#50676; &#48516;&#54624; . 분할은 쌓기의 반대입니다. 예를 들어 vsplit 함수는 행렬을 수직으로 분할합니다. . 먼저 6x4 행렬을 만들어 보죠: . r = np.arange(24).reshape(6,4) r . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]) . 수직으로 동일한 크기로 나누어 보겠습니다: . r1, r2, r3 = np.vsplit(r, 3) r1 . array([[0, 1, 2, 3], [4, 5, 6, 7]]) . r2 . array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) . r3 . array([[16, 17, 18, 19], [20, 21, 22, 23]]) . split 함수는 주어진 축을 따라 배열을 분할합니다. vsplit는 axis=0으로 split를 호출하는 것과 같습니다. hsplit 함수는 axis=1로 split를 호출하는 것과 같습니다: . r4, r5 = np.hsplit(r, 2) r4 . array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13], [16, 17], [20, 21]]) . r5 . array([[ 2, 3], [ 6, 7], [10, 11], [14, 15], [18, 19], [22, 23]]) . &#48176;&#50676; &#51204;&#52824; . transpose 메서드는 주어진 순서대로 축을 뒤바꾸어 ndarray 데이터에 대한 새로운 뷰를 만듭니다. . 예를 위해 3D 배열을 만들어 보죠: . t = np.arange(24).reshape(4,2,3) t . array([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]], [[12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23]]]) . 0, 1, 2(깊이, 높이, 너비) 축을 1, 2, 0 (깊이→너비, 높이→깊이, 너비→높이) 순서로 바꾼 ndarray를 만들어 보겠습니다: . t1 = t.transpose((1,2,0)) t1 . array([[[ 0, 6, 12, 18], [ 1, 7, 13, 19], [ 2, 8, 14, 20]], [[ 3, 9, 15, 21], [ 4, 10, 16, 22], [ 5, 11, 17, 23]]]) . t1.shape . (2, 3, 4) . transpose 기본값은 차원의 순서를 역전시킵니다: . t2 = t.transpose() # t.transpose((2, 1, 0))와 동일 t2 . array([[[ 0, 6, 12, 18], [ 3, 9, 15, 21]], [[ 1, 7, 13, 19], [ 4, 10, 16, 22]], [[ 2, 8, 14, 20], [ 5, 11, 17, 23]]]) . t2.shape . (3, 2, 4) . 넘파이는 두 축을 바꾸는 swapaxes 함수를 제공합니다. 예를 들어 깊이와 높이를 뒤바꾸어 t의 새로운 뷰를 만들어 보죠: . t3 = t.swapaxes(0,1) # t.transpose((1, 0, 2))와 동일 t3 . array([[[ 0, 1, 2], [ 6, 7, 8], [12, 13, 14], [18, 19, 20]], [[ 3, 4, 5], [ 9, 10, 11], [15, 16, 17], [21, 22, 23]]]) . t3.shape . (2, 4, 3) . &#49440;&#54805; &#45824;&#49688;&#54617; . 넘파이 2D 배열을 사용하면 파이썬에서 행렬을 효율적으로 표현할 수 있습니다. 주요 행렬 연산을 간단히 둘러 보겠습니다. 선형 대수학, 벡터와 행렬에 관한 자세한 내용은 Linear Algebra tutorial를 참고하세요. . &#54665;&#47148; &#51204;&#52824; . T 속성은 랭크가 2보다 크거나 같을 때 transpose()를 호출하는 것과 같습니다: . m1 = np.arange(10).reshape(2,5) m1 . array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) . m1.T . array([[0, 5], [1, 6], [2, 7], [3, 8], [4, 9]]) . T 속성은 랭크가 0이거나 1인 배열에는 아무런 영향을 미치지 않습니다: . m2 = np.arange(5) m2 . array([0, 1, 2, 3, 4]) . m2.T . array([0, 1, 2, 3, 4]) . 먼저 1D 배열을 하나의 행이 있는 행렬(2D)로 바꾼다음 전치를 수행할 수 있습니다: . m2r = m2.reshape(1,5) m2r . array([[0, 1, 2, 3, 4]]) . m2r.T . array([[0], [1], [2], [3], [4]]) . &#54665;&#47148; &#44273;&#49480; . 두 개의 행렬을 만들어 dot 메서드로 행렬 곱셈을 실행해 보죠. . n1 = np.arange(10).reshape(2, 5) n1 . array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) . n2 = np.arange(15).reshape(5,3) n2 . array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]]) . n1.dot(n2) . array([[ 90, 100, 110], [240, 275, 310]]) . 주의: 앞서 언급한 것처럼 n1*n2는 행렬 곱셈이 아니라 원소별 곱셈(또는 아다마르 곱이라 부릅니다)입니다. . &#50669;&#54665;&#47148;&#44284; &#50976;&#49324; &#50669;&#54665;&#47148; . numpy.linalg 모듈 안에 많은 선형 대수 함수들이 있습니다. 특히 inv 함수는 정방 행렬의 역행렬을 계산합니다: . import numpy.linalg as linalg m3 = np.array([[1,2,3],[5,7,11],[21,29,31]]) m3 . array([[ 1, 2, 3], [ 5, 7, 11], [21, 29, 31]]) . linalg.inv(m3) . array([[-2.31818182, 0.56818182, 0.02272727], [ 1.72727273, -0.72727273, 0.09090909], [-0.04545455, 0.29545455, -0.06818182]]) . pinv 함수를 사용하여 유사 역행렬을 계산할 수도 있습니다: . linalg.pinv(m3) . array([[-2.31818182, 0.56818182, 0.02272727], [ 1.72727273, -0.72727273, 0.09090909], [-0.04545455, 0.29545455, -0.06818182]]) . &#45800;&#50948; &#54665;&#47148; . 행렬과 그 행렬의 역행렬을 곱하면 단위 행렬이 됩니다(작은 소숫점 오차가 있습니다): . m3.dot(linalg.inv(m3)) . array([[ 1.00000000e+00, -1.66533454e-16, 0.00000000e+00], [ 6.31439345e-16, 1.00000000e+00, -1.38777878e-16], [ 5.21110932e-15, -2.38697950e-15, 1.00000000e+00]]) . eye 함수는 NxN 크기의 단위 행렬을 만듭니다: . np.eye(3) . array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) . QR &#48516;&#54644; . qr 함수는 행렬을 QR 분해합니다: . q, r = linalg.qr(m3) q . array([[-0.04627448, 0.98786672, 0.14824986], [-0.23137241, 0.13377362, -0.96362411], [-0.97176411, -0.07889213, 0.22237479]]) . r . array([[-21.61018278, -29.89331494, -32.80860727], [ 0. , 0.62427688, 1.9894538 ], [ 0. , 0. , -3.26149699]]) . q.dot(r) # q.r는 m3와 같습니다 . array([[ 1., 2., 3.], [ 5., 7., 11.], [21., 29., 31.]]) . &#54665;&#47148;&#49885; . det 함수는 행렬식을 계산합니다: . linalg.det(m3) # 행렬식 계산 . 43.99999999999997 . &#44256;&#50995;&#44050;&#44284; &#44256;&#50976;&#48289;&#53552; . eig 함수는 정방 행렬의 고윳값과 고유벡터를 계산합니다: . eigenvalues, eigenvectors = linalg.eig(m3) eigenvalues # λ . array([42.26600592, -0.35798416, -2.90802176]) . eigenvectors # v . array([[-0.08381182, -0.76283526, -0.18913107], [-0.3075286 , 0.64133975, -0.6853186 ], [-0.94784057, -0.08225377, 0.70325518]]) . m3.dot(eigenvectors) - eigenvalues * eigenvectors # m3.v - λ*v = 0 . array([[ 8.88178420e-15, 2.22044605e-16, -3.10862447e-15], [ 3.55271368e-15, 2.02615702e-15, -1.11022302e-15], [ 3.55271368e-14, 3.33413852e-15, -8.43769499e-15]]) . &#53945;&#51079;&#44050; &#48516;&#54644; . svd 함수는 행렬을 입력으로 받아 그 행렬의 특잇값 분해를 반환합니다: . m4 = np.array([[1,0,0,0,2], [0,0,3,0,0], [0,0,0,0,0], [0,2,0,0,0]]) m4 . array([[1, 0, 0, 0, 2], [0, 0, 3, 0, 0], [0, 0, 0, 0, 0], [0, 2, 0, 0, 0]]) . U, S_diag, V = linalg.svd(m4) U . array([[ 0., 1., 0., 0.], [ 1., 0., 0., 0.], [ 0., 0., 0., -1.], [ 0., 0., 1., 0.]]) . S_diag . array([3. , 2.23606798, 2. , 0. ]) . svd 함수는 Σ의 대각 원소 값만 반환합니다. 전체 Σ 행렬은 다음과 같이 만듭니다: . S = np.zeros((4, 5)) S[np.diag_indices(4)] = S_diag S # Σ . array([[3. , 0. , 0. , 0. , 0. ], [0. , 2.23606798, 0. , 0. , 0. ], [0. , 0. , 2. , 0. , 0. ], [0. , 0. , 0. , 0. , 0. ]]) . V . array([[-0. , 0. , 1. , -0. , 0. ], [ 0.4472136 , 0. , 0. , 0. , 0.89442719], [-0. , 1. , 0. , -0. , 0. ], [ 0. , 0. , 0. , 1. , 0. ], [-0.89442719, 0. , 0. , 0. , 0.4472136 ]]) . U.dot(S).dot(V) # U.Σ.V == m4 . array([[1., 0., 0., 0., 2.], [0., 0., 3., 0., 0.], [0., 0., 0., 0., 0.], [0., 2., 0., 0., 0.]]) . &#45824;&#44033;&#50896;&#49548;&#50752; &#45824;&#44033;&#54633; . np.diag(m3) # m3의 대각 원소입니다(왼쪽 위에서 오른쪽 아래) . array([ 1, 7, 31]) . np.trace(m3) # np.diag(m3).sum()와 같습니다 . 39 . &#49440;&#54805; &#48169;&#51221;&#49885; &#54400;&#44592; . solve 함수는 다음과 같은 선형 방정식을 풉니다: . $2x + 6y = 6$ | $5x + 3y = -9$ | . coeffs = np.array([[2, 6], [5, 3]]) depvars = np.array([6, -9]) solution = linalg.solve(coeffs, depvars) solution . array([-3., 2.]) . solution을 확인해 보죠: . coeffs.dot(solution), depvars # 네 같네요 . (array([ 6., -9.]), array([ 6, -9])) . 좋습니다! 다른 방식으로도 solution을 확인해 보죠: . np.allclose(coeffs.dot(solution), depvars) . True . &#48289;&#53552;&#54868; . 한 번에 하나씩 개별 배열 원소에 대해 연산을 실행하는 대신 배열 연산을 사용하면 훨씬 효율적인 코드를 만들 수 있습니다. 이를 벡터화라고 합니다. 이를 사용하여 넘파이의 최적화된 성능을 활용할 수 있습니다. . 예를 들어, $sin(xy/40.5)$ 식을 기반으로 768x1024 크기 배열을 생성하려고 합니다. 중첩 반복문 안에 파이썬의 math 함수를 사용하는 것은 나쁜 방법입니다: . import math data = np.empty((768, 1024)) for y in range(768): for x in range(1024): data[y, x] = math.sin(x*y/40.5) # 매우 비효율적입니다! . 작동은 하지만 순수한 파이썬 코드로 반복문이 진행되기 때문에 아주 비효율적입니다. 이 알고리즘을 벡터화해 보죠. 먼저 넘파이 meshgrid 함수로 좌표 벡터를 사용해 행렬을 만듭니다. . x_coords = np.arange(0, 1024) # [0, 1, 2, ..., 1023] y_coords = np.arange(0, 768) # [0, 1, 2, ..., 767] X, Y = np.meshgrid(x_coords, y_coords) X . array([[ 0, 1, 2, ..., 1021, 1022, 1023], [ 0, 1, 2, ..., 1021, 1022, 1023], [ 0, 1, 2, ..., 1021, 1022, 1023], ..., [ 0, 1, 2, ..., 1021, 1022, 1023], [ 0, 1, 2, ..., 1021, 1022, 1023], [ 0, 1, 2, ..., 1021, 1022, 1023]]) . Y . array([[ 0, 0, 0, ..., 0, 0, 0], [ 1, 1, 1, ..., 1, 1, 1], [ 2, 2, 2, ..., 2, 2, 2], ..., [765, 765, 765, ..., 765, 765, 765], [766, 766, 766, ..., 766, 766, 766], [767, 767, 767, ..., 767, 767, 767]]) . 여기서 볼 수 있듯이 X와 Y 모두 768x1024 배열입니다. X에 있는 모든 값은 수평 좌표에 해당합니다. Y에 있는 모든 값은 수직 좌표에 해당합니다. . 이제 간단히 배열 연산을 사용해 계산할 수 있습니다: . data = np.sin(X*Y/40.5) . 맷플롯립의 imshow 함수를 사용해 이 데이터를 그려보죠(matplotlib tutorial을 참조하세요). . import matplotlib.pyplot as plt import matplotlib.cm as cm fig = plt.figure(1, figsize=(7, 6)) plt.imshow(data, cmap=cm.hot) plt.show() . &#51200;&#51109;&#44284; &#47196;&#46377; . 넘파이는 ndarray를 바이너리 또는 텍스트 포맷으로 손쉽게 저장하고 로드할 수 있습니다. . &#48148;&#51060;&#45320;&#47532; .npy &#54252;&#47607; . 랜덤 배열을 만들고 저장해 보죠. . a = np.random.rand(2,3) a . array([[0.5435938 , 0.92886307, 0.01535158], [0.4157283 , 0.9102127 , 0.55129708]]) . np.save(&quot;my_array&quot;, a) . 끝입니다! 파일 이름의 확장자를 지정하지 않았기 때문에 넘파이는 자동으로 .npy를 붙입니다. 파일 내용을 확인해 보겠습니다: . with open(&quot;my_array.npy&quot;, &quot;rb&quot;) as f: content = f.read() content . b&#34; x93NUMPY x01 x00v x00{&#39;descr&#39;: &#39;&lt;f8&#39;, &#39;fortran_order&#39;: False, &#39;shape&#39;: (2, 3), } nY xc1 xfc xd0 x1ee xe1? xde{3 t? xb9 xed? x80V x08 xef xa5p x8f? x96I} xe0J x9b xda? xe0U xfaav xed? xd8 xe50 xc59 xa4 xe1?&#34; . 이 파일을 넘파이 배열로 로드하려면 load 함수를 사용합니다: . a_loaded = np.load(&quot;my_array.npy&quot;) a_loaded . array([[0.5435938 , 0.92886307, 0.01535158], [0.4157283 , 0.9102127 , 0.55129708]]) . &#53581;&#49828;&#53944; &#54252;&#47607; . 배열을 텍스트 포맷으로 저장해 보죠: . np.savetxt(&quot;my_array.csv&quot;, a) . 파일 내용을 확인해 보겠습니다: . with open(&quot;my_array.csv&quot;, &quot;rt&quot;) as f: print(f.read()) . 5.435937959464737235e-01 9.288630656918674955e-01 1.535157809943688001e-02 4.157283012656532994e-01 9.102126992826775620e-01 5.512970782648904944e-01 . 이 파일은 탭으로 구분된 CSV 파일입니다. 다른 구분자를 지정할 수도 있습니다: . np.savetxt(&quot;my_array.csv&quot;, a, delimiter=&quot;,&quot;) . 이 파일을 로드하려면 loadtxt 함수를 사용합니다: . a_loaded = np.loadtxt(&quot;my_array.csv&quot;, delimiter=&quot;,&quot;) a_loaded . array([[0.5435938 , 0.92886307, 0.01535158], [0.4157283 , 0.9102127 , 0.55129708]]) . &#50517;&#52629;&#46108; .npz &#54252;&#47607; . 여러 개의 배열을 압축된 한 파일로 저장하는 것도 가능합니다: . b = np.arange(24, dtype=np.uint8).reshape(2, 3, 4) b . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]], dtype=uint8) . np.savez(&quot;my_arrays&quot;, my_a=a, my_b=b) . 파일 내용을 확인해 보죠. .npz 파일 확장자가 자동으로 추가되었습니다. . with open(&quot;my_arrays.npz&quot;, &quot;rb&quot;) as f: content = f.read() repr(content)[:180] + &quot;[...]&quot; . &#39;b&#34;PK x03 x04 x14 x00 x00 x00 x00 x00 x00 x00! x00 x063 xcf xb9 xb0 x00 x00 x00 xb0 x00 x00 x00 x08 x00 x14 x00my_a.npy x01 x00 x10 x00 xb0 x00 x00 x00 x00 x00 x00 x00 xb0 x00 x00 x[...]&#39; . 다음과 같이 이 파일을 로드할 수 있습니다: . my_arrays = np.load(&quot;my_arrays.npz&quot;) my_arrays . &lt;numpy.lib.npyio.NpzFile at 0x7f9791c73d60&gt; . 게으른 로딩을 수행하는 딕셔너리와 유사한 객체입니다: . my_arrays.keys() . KeysView(&lt;numpy.lib.npyio.NpzFile object at 0x7f9791c73d60&gt;) . my_arrays[&quot;my_a&quot;] . array([[0.5435938 , 0.92886307, 0.01535158], [0.4157283 , 0.9102127 , 0.55129708]]) . &#44536; &#45796;&#51020;&#51008;? . 넘파이 기본 요소를 모두 배웠지만 훨씬 더 많은 기능이 있습니다. 이를 배우는 가장 좋은 방법은 넘파이를 직접 실습해 보고 훌륭한 넘파이 문서에서 필요한 함수와 기능을 찾아 보세요. .",
            "url": "https://kangsuin01.github.io/suin_blog/jupyter/python/2022/05/28/_03_11_numpy.html",
            "relUrl": "/jupyter/python/2022/05/28/_03_11_numpy.html",
            "date": " • May 28, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "kaggle - Geospatial Analysis05",
            "content": "5. Exercise: Proximity Analysis . 소개 . 여러분은 위기 대응 팀의 일원이며, 뉴욕 시에서 병원들이 충돌 사고에 어떻게 대응해 왔는지를 확인하려고 합니다. . import math import geopandas as gpd import pandas as pd from shapely.geometry import MultiPolygon import folium from folium import Choropleth, Marker from folium.plugins import HeatMap, MarkerCluster . def embed_map(m, file_name): from IPython.display import IFrame m.save(file_name) return IFrame(file_name, width=&#39;100%&#39;, height=&#39;500px&#39;) . 5-1. &#52649;&#46028; &#45936;&#51060;&#53552;&#47484; &#49884;&#44033;&#54868;&#54633;&#45768;&#45796;. . 아래 코드 셀을 실행하여 2013-2018년의 주요 자동차 충돌을 추적하는 GeoDataFrame 충돌을 로드합니다. . collisions = gpd.read_file(&quot;C:/Users/Kangdaeyong/Desktop/datamining/kaggle_geospatial_analysis/archive/NYPD_Motor_Vehicle_Collisions/NYPD_Motor_Vehicle_Collisions/NYPD_Motor_Vehicle_Collisions.shp&quot;) collisions.head() . DATE TIME BOROUGH ZIP CODE LATITUDE LONGITUDE LOCATION ON STREET CROSS STRE OFF STREET ... CONTRIBU_2 CONTRIBU_3 CONTRIBU_4 UNIQUE KEY VEHICLE TY VEHICLE _1 VEHICLE _2 VEHICLE _3 VEHICLE _4 geometry . 0 07/30/2019 | 0:00 | BRONX | 10464 | 40.841100 | -73.784960 | (40.8411, -73.78496) | None | None | 121 PILOT STREET | ... | Unspecified | None | None | 4180045 | Sedan | Station Wagon/Sport Utility Vehicle | Station Wagon/Sport Utility Vehicle | None | None | POINT (1043750.211 245785.815) | . 1 07/30/2019 | 0:10 | QUEENS | 11423 | 40.710827 | -73.770660 | (40.710827, -73.77066) | JAMAICA AVENUE | 188 STREET | None | ... | None | None | None | 4180007 | Sedan | Sedan | None | None | None | POINT (1047831.185 198333.171) | . 2 07/30/2019 | 0:25 | None | None | 40.880318 | -73.841286 | (40.880318, -73.841286) | BOSTON ROAD | None | None | ... | None | None | None | 4179575 | Sedan | Station Wagon/Sport Utility Vehicle | None | None | None | POINT (1028139.293 260041.178) | . 3 07/30/2019 | 0:35 | MANHATTAN | 10036 | 40.756744 | -73.984590 | (40.756744, -73.98459) | None | None | 155 WEST 44 STREET | ... | None | None | None | 4179544 | Box Truck | Station Wagon/Sport Utility Vehicle | None | None | None | POINT (988519.261 214979.320) | . 4 07/30/2019 | 10:00 | BROOKLYN | 11223 | 40.600090 | -73.965910 | (40.60009, -73.96591) | AVENUE T | OCEAN PARKWAY | None | ... | None | None | None | 4180660 | Station Wagon/Sport Utility Vehicle | Bike | None | None | None | POINT (993716.669 157907.212) | . 5 rows × 30 columns . &quot;LATITUDE&quot; 및 &quot;LONGITUDE&quot; 열을 사용하여 충돌 데이터를 시각화하는 대화형 지도를 만듭니다. 어떤 유형의 지도가 가장 효과적이라고 생각하십니까? . m_1 = folium.Map(location=[40.7, -74], zoom_start=11) # Your code here: Visualize the collision data # Visualize the collision data HeatMap(data=collisions[[&#39;LATITUDE&#39;, &#39;LONGITUDE&#39;]], radius=9).add_to(m_1) m_1 . Make this Notebook Trusted to load map: File -&gt; Trust Notebook 5.2. &#48337;&#50896; &#48372;&#54744; &#51201;&#50857; &#48276;&#50948;&#47484; &#54028;&#50501;&#54633;&#45768;&#45796;. . 다음 코드 셀을 실행하여 병원 데이터를 로드합니다. . hospitals = gpd.read_file(&quot;C:/Users/Kangdaeyong/Desktop/datamining/kaggle_geospatial_analysis/archive/nyu_2451_34494/nyu_2451_34494/nyu_2451_34494.shp&quot;) hospitals.head() . id name address zip factype facname capacity capname bcode xcoord ycoord latitude longitude geometry . 0 317000001H1178 | BRONX-LEBANON HOSPITAL CENTER - CONCOURSE DIVI... | 1650 Grand Concourse | 10457 | 3102 | Hospital | 415 | Beds | 36005 | 1008872.0 | 246596.0 | 40.843490 | -73.911010 | POINT (1008872.000 246596.000) | . 1 317000001H1164 | BRONX-LEBANON HOSPITAL CENTER - FULTON DIVISION | 1276 Fulton Ave | 10456 | 3102 | Hospital | 164 | Beds | 36005 | 1011044.0 | 242204.0 | 40.831429 | -73.903178 | POINT (1011044.000 242204.000) | . 2 317000011H1175 | CALVARY HOSPITAL INC | 1740-70 Eastchester Rd | 10461 | 3102 | Hospital | 225 | Beds | 36005 | 1027505.0 | 248287.0 | 40.848060 | -73.843656 | POINT (1027505.000 248287.000) | . 3 317000002H1165 | JACOBI MEDICAL CENTER | 1400 Pelham Pkwy | 10461 | 3102 | Hospital | 457 | Beds | 36005 | 1027042.0 | 251065.0 | 40.855687 | -73.845311 | POINT (1027042.000 251065.000) | . 4 317000008H1172 | LINCOLN MEDICAL &amp; MENTAL HEALTH CENTER | 234 E 149 St | 10451 | 3102 | Hospital | 362 | Beds | 36005 | 1005154.0 | 236853.0 | 40.816758 | -73.924478 | POINT (1005154.000 236853.000) | . &quot;위도&quot; 및 &quot;경도&quot; 열을 사용하여 병원 위치를 시각화합니다. . m_2 = folium.Map(location=[40.7, -74], zoom_start=11) # Your code here: Visualize the hospital locations # Visualize the hospital locations for idx, row in hospitals.iterrows(): Marker([row[&#39;latitude&#39;], row[&#39;longitude&#39;]], popup=row[&#39;name&#39;]).add_to(m_2) # Uncomment to see a hint #q_2.hint() # Show the map m_2 . Make this Notebook Trusted to load map: File -&gt; Trust Notebook 5.3. &#44032;&#51109; &#44032;&#44620;&#50868; &#48337;&#50896;&#51060; 10km &#51060;&#49345; &#46504;&#50612;&#51652; &#46412;&#45716; &#50616;&#51228;&#50688;&#49845;&#45768;&#44620;? . 가장 가까운 병원에서 10km 이상 떨어진 곳에서 발생한 충돌 충돌의 모든 행을 포함하는 DataFrame outside_range를 만듭니다. . 병원과 충돌 모두 좌표 참조 시스템으로 EPSG 2263이 있고 EPSG 2263에는 미터 단위가 있습니다. . outside_range = coverage = gpd.GeoDataFrame(geometry=hospitals.geometry).buffer(10000) my_union = coverage.geometry.unary_union outside_range = collisions.loc[~collisions[&quot;geometry&quot;].apply(lambda x: my_union.contains(x))] . 다음 코드 셀은 가장 가까운 병원에서 10km 이상 떨어진 곳에서 발생한 충돌의 비율을 계산합니다. . percentage = round(100*len(outside_range)/len(collisions), 2) print(&quot;Percentage of collisions more than 10 km away from the closest hospital: {}%&quot;.format(percentage)) . Percentage of collisions more than 10 km away from the closest hospital: 15.12% . 5.4. &#52628;&#52380;&#51064;&#51012; &#47564;&#46304;&#45796;. . 멀리 떨어진 곳에서 충돌이 발생하면 부상자를 가까운 병원으로 이송하는 것이 더욱 중요해집니다. . 이를 염두에 두고 다음과 같은 추천자를 만들기로 결정합니다. . 충돌 위치(EPSG 2263)를 입력으로 사용합니다. | 가장 가까운 병원(거리 계산이 EPSG 2263에서 수행되는 곳)을 찾고, | 가장 가까운 병원의 이름을 반환합니다. | . collisions.head() . DATE TIME BOROUGH ZIP CODE LATITUDE LONGITUDE LOCATION ON STREET CROSS STRE OFF STREET ... CONTRIBU_2 CONTRIBU_3 CONTRIBU_4 UNIQUE KEY VEHICLE TY VEHICLE _1 VEHICLE _2 VEHICLE _3 VEHICLE _4 geometry . 0 07/30/2019 | 0:00 | BRONX | 10464 | 40.841100 | -73.784960 | (40.8411, -73.78496) | None | None | 121 PILOT STREET | ... | Unspecified | None | None | 4180045 | Sedan | Station Wagon/Sport Utility Vehicle | Station Wagon/Sport Utility Vehicle | None | None | POINT (1043750.211 245785.815) | . 1 07/30/2019 | 0:10 | QUEENS | 11423 | 40.710827 | -73.770660 | (40.710827, -73.77066) | JAMAICA AVENUE | 188 STREET | None | ... | None | None | None | 4180007 | Sedan | Sedan | None | None | None | POINT (1047831.185 198333.171) | . 2 07/30/2019 | 0:25 | None | None | 40.880318 | -73.841286 | (40.880318, -73.841286) | BOSTON ROAD | None | None | ... | None | None | None | 4179575 | Sedan | Station Wagon/Sport Utility Vehicle | None | None | None | POINT (1028139.293 260041.178) | . 3 07/30/2019 | 0:35 | MANHATTAN | 10036 | 40.756744 | -73.984590 | (40.756744, -73.98459) | None | None | 155 WEST 44 STREET | ... | None | None | None | 4179544 | Box Truck | Station Wagon/Sport Utility Vehicle | None | None | None | POINT (988519.261 214979.320) | . 4 07/30/2019 | 10:00 | BROOKLYN | 11223 | 40.600090 | -73.965910 | (40.60009, -73.96591) | AVENUE T | OCEAN PARKWAY | None | ... | None | None | None | 4180660 | Station Wagon/Sport Utility Vehicle | Bike | None | None | None | POINT (993716.669 157907.212) | . 5 rows × 30 columns . def best_hospital(collision_location): idx_min = hospitals.geometry.distance(collision_location).idxmin() my_hospital = hospitals.iloc[idx_min] name = my_hospital[&quot;name&quot;] return name # Test your function: this should suggest CALVARY HOSPITAL INC print(best_hospital(outside_range.geometry.iloc[0])) . CALVARY HOSPITAL INC . 5.5. &#49688;&#50836;&#44032; &#44032;&#51109; &#47566;&#51008; &#48337;&#50896;&#51008;? . outside_range DataFrame에서 충돌만 고려한다면 어느 병원을 가장 추천하는가? . 답은 4)에서 생성한 함수에서 반환한 병원 이름과 정확히 일치하는 Python 문자열이어야 합니다. . highest_demand = outside_range.geometry.apply(best_hospital).value_counts().idxmax() . highest_demand . &#39;JAMAICA HOSPITAL MEDICAL CENTER&#39; . 5.6. &#46020;&#49884;&#45716; &#50612;&#46356;&#50640; &#49352; &#48337;&#50896;&#51012; &#51648;&#50612;&#50556; &#54633;&#45768;&#44620;? . 다음 코드 셀(변경 없이)을 실행하여 가장 가까운 병원에서 10km 이상 떨어진 곳에서 발생한 충돌 외에도 병원 위치를 시각화합니다. . m_6 = folium.Map(location=[40.7, -74], zoom_start=11) coverage = gpd.GeoDataFrame(geometry=hospitals.geometry).buffer(10000) folium.GeoJson(coverage.geometry.to_crs(epsg=4326)).add_to(m_6) HeatMap(data=outside_range[[&#39;LATITUDE&#39;, &#39;LONGITUDE&#39;]], radius=9).add_to(m_6) folium.LatLngPopup().add_to(m_6) m_6 . Make this Notebook Trusted to load map: File -&gt; Trust Notebook 지도의 아무 곳이나 클릭하면 해당 위치의 위도 및 경도 팝업이 표시됩니다. . New York 시는 두 곳의 새로운 병원을 지을 위치를 결정하는 데 도움을 드리기 위해 연락을 드립니다. 그들은 특히 3) 단계에서 계산된 백분율을 10% 미만으로 만들기 위해 위치 식별에 대한 귀하의 도움을 원합니다. 지도를 사용하여(지역 설정법이나 병원을 건설하기 위해 제거해야 할 잠재적 건물에 대해 걱정하지 않고) 도시가 이 목표를 달성하는 데 도움이 되는 두 위치를 식별할 수 있습니까? . 병원 1에 대해 제안된 위도와 경도를 각각 lat_1과 long_1에 넣습니다. (병원2도 마찬가지) . 그런 다음 나머지 셀을 그대로 실행하여 새 병원의 효과를 확인하십시오. 두 개의 새로운 병원에서 백분율을 10% 미만으로 낮추면 답이 정답으로 표시됩니다. . lat_1 = 40.6714 long_1 = -73.8492 # Proposed location of hospital 2 lat_2 = 40.6702 long_2 = -73.7612 # Do not modify the code below this line try: new_df = pd.DataFrame( {&#39;Latitude&#39;: [lat_1, lat_2], &#39;Longitude&#39;: [long_1, long_2]}) new_gdf = gpd.GeoDataFrame(new_df, geometry=gpd.points_from_xy(new_df.Longitude, new_df.Latitude)) new_gdf.crs = {&#39;init&#39; :&#39;epsg:4326&#39;} new_gdf = new_gdf.to_crs(epsg=2263) # get new percentage new_coverage = gpd.GeoDataFrame(geometry=new_gdf.geometry).buffer(10000) new_my_union = new_coverage.geometry.unary_union new_outside_range = outside_range.loc[~outside_range[&quot;geometry&quot;].apply(lambda x: new_my_union.contains(x))] new_percentage = round(100*len(new_outside_range)/len(collisions), 2) print(&quot;(NEW) Percentage of collisions more than 10 km away from the closest hospital: {}%&quot;.format(new_percentage)) # Did you help the city to meet its goal? q_6.check() # make the map m = folium.Map(location=[40.7, -74], zoom_start=11) folium.GeoJson(coverage.geometry.to_crs(epsg=4326)).add_to(m) folium.GeoJson(new_coverage.geometry.to_crs(epsg=4326)).add_to(m) for idx, row in new_gdf.iterrows(): Marker([row[&#39;Latitude&#39;], row[&#39;Longitude&#39;]]).add_to(m) HeatMap(data=new_outside_range[[&#39;LATITUDE&#39;, &#39;LONGITUDE&#39;]], radius=9).add_to(m) folium.LatLngPopup().add_to(m) display(embed_map(m, &#39;q_6.html&#39;)) except: print(&#39;a&#39;) . c: Users Kangdaeyong anaconda3 lib site-packages pyproj crs crs.py:130: FutureWarning: &#39;+init=&lt;authority&gt;:&lt;code&gt;&#39; syntax is deprecated. &#39;&lt;authority&gt;:&lt;code&gt;&#39; is the preferred initialization method. When making the change, be mindful of axis order changes: https://pyproj4.github.io/pyproj/stable/gotchas.html#axis-order-changes-in-proj-6 in_crs_string = _prepare_from_proj_string(in_crs_string) . (NEW) Percentage of collisions more than 10 km away from the closest hospital: 9.12% a .",
            "url": "https://kangsuin01.github.io/suin_blog/2022/05/20/first-map-exercise5.html",
            "relUrl": "/2022/05/20/first-map-exercise5.html",
            "date": " • May 20, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "kaggle - Geospatial Analysis04",
            "content": "4. Exercise: Manipulating Geospatial Data . 소개 당신은 Starbucks Reserve Roastery의 다음 매장을 찾고 있는 Starbucks 빅 데이터 분석가입니다. 이 로스터리는 일반적인 스타벅스 매장보다 훨씬 크며 고급 라운지 공간과 함께 다양한 음식과 와인 옵션을 비롯한 몇 가지 추가 기능을 갖추고 있습니다. 캘리포니아 주에 있는 여러 카운티의 인구 통계를 조사하여 잠재적으로 적합한 위치를 결정합니다. . import math import pandas as pd import geopandas as gpd from geopy.geocoders import Nominatim # What you&#39;d normally run #from learntools.geospatial.tools import Nominatim # Just for this exercise import folium from folium import Marker from folium.plugins import MarkerCluster . 이전 연습의 embed_map() 함수를 사용하여 지도를 시각화합니다. . def embed_map(m, file_name): from IPython.display import IFrame m.save(file_name) return IFrame(file_name, width=&#39;100%&#39;, height=&#39;500px&#39;) . 4.1 &#45572;&#46973;&#46108; &#50948;&#52824;&#47484; &#51648;&#50724;&#53076;&#46377;&#54633;&#45768;&#45796;. . 다음 코드 셀을 실행하여 캘리포니아 주에 있는 Starbucks 위치를 포함하는 DataFrame 스타벅스를 만듭니다. . starbucks = pd.read_csv(&quot;C:/Users/Kangdaeyong/Desktop/datamining/kaggle_geospatial_analysis/archive/starbucks_locations.csv&quot;) starbucks.head() . Store Number Store Name Address City Longitude Latitude . 0 10429-100710 | Palmdale &amp; Hwy 395 | 14136 US Hwy 395 Adelanto CA | Adelanto | -117.40 | 34.51 | . 1 635-352 | Kanan &amp; Thousand Oaks | 5827 Kanan Road Agoura CA | Agoura | -118.76 | 34.16 | . 2 74510-27669 | Vons-Agoura Hills #2001 | 5671 Kanan Rd. Agoura Hills CA | Agoura Hills | -118.76 | 34.15 | . 3 29839-255026 | Target Anaheim T-0677 | 8148 E SANTA ANA CANYON ROAD AHAHEIM CA | AHAHEIM | -117.75 | 33.87 | . 4 23463-230284 | Safeway - Alameda 3281 | 2600 5th Street Alameda CA | Alameda | -122.28 | 37.79 | . 대부분의 상점은 (위도, 경도) 위치를 알고 있습니다. 그러나 버클리시의 모든 위치가 누락되었습니다. . print(starbucks.isnull().sum()) # View rows with missing locations rows_with_missing = starbucks[starbucks[&quot;City&quot;]==&quot;Berkeley&quot;] rows_with_missing . Store Number 0 Store Name 0 Address 0 City 0 Longitude 5 Latitude 5 dtype: int64 . Store Number Store Name Address City Longitude Latitude . 153 5406-945 | 2224 Shattuck - Berkeley | 2224 Shattuck Avenue Berkeley CA | Berkeley | NaN | NaN | . 154 570-512 | Solano Ave | 1799 Solano Avenue Berkeley CA | Berkeley | NaN | NaN | . 155 17877-164526 | Safeway - Berkeley #691 | 1444 Shattuck Place Berkeley CA | Berkeley | NaN | NaN | . 156 19864-202264 | Telegraph &amp; Ashby | 3001 Telegraph Avenue Berkeley CA | Berkeley | NaN | NaN | . 157 9217-9253 | 2128 Oxford St. | 2128 Oxford Street Berkeley CA | Berkeley | NaN | NaN | . 아래 코드 셀을 사용하여 Nominatim 지오코더로 이 값을 채우십시오. . 튜토리얼에서 우리는 값을 지오코딩하기 위해 Nominatim()(geopy.geocoders에서)을 사용했으며 이것은 이 과정 이외의 자체 프로젝트에서 사용할 수 있는 것입니다. . 이 연습에서는 약간 다른 함수 Nominatim()을 사용합니다(learntools.geospatial.tools에서). 이 기능은 노트북 상단에서 가져온 것으로 GeoPandas의 기능과 동일하게 작동합니다. . 즉,노트북 상단의 import 문을 변경하지 않고 아래 코드 셀에서 지오코딩 함수를 geocode()로 호출합니다. 코드가 의도한 대로 작동합니다! . geolocator = Nominatim(user_agent=&quot;kaggle_learn&quot;) def my_geocoder(row): point = geolocator.geocode(row).point return pd.Series({&#39;Latitude&#39;: point.latitude, &#39;Longitude&#39;: point.longitude}) berkeley_locations = rows_with_missing.apply(lambda x: my_geocoder(x[&#39;Address&#39;]), axis=1) starbucks.update(berkeley_locations) . 4.2. &#48260;&#53364;&#47532; &#50948;&#52824; &#48372;&#44592;&#182; . 방금 찾은 위치를 살펴보겠습니다. OpenStreetMap 스타일로 버클리의 (위도, 경도) 위치를 시각화합니다. . m_2 = folium.Map(location=[37.88,-122.26], zoom_start=13) # Your code here: Add a marker for each Berkeley location # Add a marker for each Berkeley location for idx, row in starbucks[starbucks[&quot;City&quot;]==&#39;Berkeley&#39;].iterrows(): Marker([row[&#39;Latitude&#39;], row[&#39;Longitude&#39;]]).add_to(m_2) m_2 . Make this Notebook Trusted to load map: File -&gt; Trust Notebook 버클리의 5개 위치만 고려할 때 (위도, 경도) 위치가 잠재적으로 정확해 보이는 위치(올바른 도시에 위치)는 몇 개입니까? . =&gt; 5개 모두 다 맞는 것 같습니다. . 4.3. &#45936;&#51060;&#53552;&#47484; &#53685;&#54633;&#54633;&#45768;&#45796;. . 아래 코드를 실행하여 캘리포니아 주의 각 카운티에 대한 이름, 면적(제곱 킬로미터) 및 고유 ID(&quot;GEOID&quot; 열에 있음)를 포함하는 GeoDataFrame CA_counties를 로드합니다. &quot;형상&quot; 열에는 카운티 경계가 있는 다각형이 포함되어 있습니다. . CA_counties = gpd.read_file(&quot;C:/Users/Kangdaeyong/Desktop/datamining/kaggle_geospatial_analysis/archive/CA_county_boundaries/CA_county_boundaries/CA_county_boundaries.shp&quot;) CA_counties.head() . GEOID name area_sqkm geometry . 0 6091 | Sierra County | 2491.995494 | POLYGON ((-120.65560 39.69357, -120.65554 39.6... | . 1 6067 | Sacramento County | 2575.258262 | POLYGON ((-121.18858 38.71431, -121.18732 38.7... | . 2 6083 | Santa Barbara County | 9813.817958 | MULTIPOLYGON (((-120.58191 34.09856, -120.5822... | . 3 6009 | Calaveras County | 2685.626726 | POLYGON ((-120.63095 38.34111, -120.63058 38.3... | . 4 6111 | Ventura County | 5719.321379 | MULTIPOLYGON (((-119.63631 33.27304, -119.6360... | . 다음으로 3개의 DataFrame을 생성합니다. . CA_pop에는 각 카운티의 인구 추정치가 포함됩니다. CA_high_earners에는 연간 소득이 $150,000 이상인 가구 수가 포함됩니다. CA_median_age에는 각 카운티의 중간 연령이 포함됩니다. . CA_pop = pd.read_csv(&quot;C:/Users/Kangdaeyong/Desktop/datamining/kaggle_geospatial_analysis/archive/CA_county_population.csv&quot;, index_col=&quot;GEOID&quot;) CA_high_earners = pd.read_csv(&quot;C:/Users/Kangdaeyong/Desktop/datamining/kaggle_geospatial_analysis/archive/CA_county_high_earners.csv&quot;, index_col=&quot;GEOID&quot;) CA_median_age = pd.read_csv(&quot;C:/Users/Kangdaeyong/Desktop/datamining/kaggle_geospatial_analysis/archive/CA_county_median_age.csv&quot;, index_col=&quot;GEOID&quot;) . 다음 코드 셀을 사용하여 CA_counties GeoDataFrame을 CA_pop, CA_high_earners 및 CA_median_age와 결합합니다. . 결과 GeoDataFrame CA_stats의 이름을 지정하고 &quot;GEOID&quot;, &quot;name&quot;, &quot;area_sqkm&quot;, &quot;geometry&quot;, &quot;population&quot;, &quot;high_earners&quot; 및 &quot;median_age&quot;의 8개 열이 있는지 확인합니다. 또한 CRS가 {&#39;init&#39;: &#39;epsg:4326&#39;}으로 설정되어 있는지 확인합니다. . cols_to_add = CA_pop.join([CA_high_earners, CA_median_age]).reset_index() CA_stats = CA_counties.merge(cols_to_add, on=&quot;GEOID&quot;) CA_stats.crs = {&#39;init&#39;: &#39;epsg:4326&#39;} . c: Users Kangdaeyong anaconda3 lib site-packages pyproj crs crs.py:130: FutureWarning: &#39;+init=&lt;authority&gt;:&lt;code&gt;&#39; syntax is deprecated. &#39;&lt;authority&gt;:&lt;code&gt;&#39; is the preferred initialization method. When making the change, be mindful of axis order changes: https://pyproj4.github.io/pyproj/stable/gotchas.html#axis-order-changes-in-proj-6 in_crs_string = _prepare_from_proj_string(in_crs_string) . 이제 모든 데이터가 한 곳에 있으므로 열 조합을 사용하는 통계를 훨씬 쉽게 계산할 수 있습니다. 다음 코드 셀을 실행하여 인구 밀도가 있는 &quot;밀도&quot; 열을 만듭니다. . CA_stats[&quot;density&quot;] = CA_stats[&quot;population&quot;] / CA_stats[&quot;area_sqkm&quot;] . 4.4. &#50612;&#45712; &#52852;&#50868;&#54000;&#44032; &#50976;&#47581;&#54644; &#48372;&#51077;&#45768;&#44620;? . 모든 정보를 단일 GeoDataFrame으로 축소하면 특정 기준을 충족하는 카운티를 훨씬 더 쉽게 선택할 수 있습니다. . 다음 코드 셀을 사용하여 CA_stats GeoDataFrame에서 행(및 모든 열)의 하위 집합을 포함하는 GeoDataFrame sel_counties를 만듭니다. 특히 다음과 같은 카운티를 선택해야 합니다. . 연간 $150,000를 버는 적어도 100,000 가구가 있고, | 중위 연령이 38.5세 미만이고, | 주민 밀도는 최소 285명(제곱 킬로미터당)입니다. | 또한 선택한 카운티는 다음 기준 중 하나 이상을 충족해야 합니다. | 연간 $150,000를 버는 적어도 500,000 가구가 있고, | 중위 연령이 35.5세 미만이거나 | 주민 밀도는 최소 1400명(제곱 킬로미터당)입니다. | . sel_counties = sel_counties = CA_stats[((CA_stats.high_earners &gt; 100000) &amp; (CA_stats.median_age &lt; 38.5) &amp; (CA_stats.density &gt; 285) &amp; ((CA_stats.median_age &lt; 35.5) | (CA_stats.density &gt; 1400) | (CA_stats.high_earners &gt; 500000)))] sel_counties . GEOID name area_sqkm geometry population high_earners median_age density . 5 6037 | Los Angeles County | 12305.376879 | MULTIPOLYGON (((-118.66761 33.47749, -118.6682... | 10105518 | 501413 | 36.0 | 821.227834 | . 8 6073 | San Diego County | 11721.342229 | POLYGON ((-117.43744 33.17953, -117.44955 33.1... | 3343364 | 194676 | 35.4 | 285.237299 | . 10 6075 | San Francisco County | 600.588247 | MULTIPOLYGON (((-122.60025 37.80249, -122.6123... | 883305 | 114989 | 38.3 | 1470.733077 | . 4.5. &#47751; &#44060;&#51032; &#47588;&#51109;&#51012; &#49885;&#48324;&#54664;&#49845;&#45768;&#44620;? . 다음 Starbucks Reserve Roastery 위치를 찾을 때 선택한 카운티 내의 모든 매장을 고려하고 싶습니다. 그렇다면 선택한 카운티 내에 몇 개의 매장이 있습니까? . 이 질문에 답할 준비를 하려면 다음 코드 셀을 실행하여 모든 스타벅스 위치가 포함된 GeoDataFrame starbucks_gdf를 만듭니다. . starbucks_gdf = gpd.GeoDataFrame(starbucks, geometry=gpd.points_from_xy(starbucks.Longitude, starbucks.Latitude)) starbucks_gdf.crs = {&#39;init&#39;: &#39;epsg:4326&#39;} . c: Users Kangdaeyong anaconda3 lib site-packages pyproj crs crs.py:130: FutureWarning: &#39;+init=&lt;authority&gt;:&lt;code&gt;&#39; syntax is deprecated. &#39;&lt;authority&gt;:&lt;code&gt;&#39; is the preferred initialization method. When making the change, be mindful of axis order changes: https://pyproj4.github.io/pyproj/stable/gotchas.html#axis-order-changes-in-proj-6 in_crs_string = _prepare_from_proj_string(in_crs_string) . 그렇다면 선택한 카운티에는 몇 개의 매장이 있습니까? . num_stores = locations_of_interest = gpd.sjoin(starbucks_gdf, sel_counties) num_stores = len(locations_of_interest) num_stores . 1043 . 4.6. &#47588;&#51109; &#50948;&#52824;&#47484; &#8203;&#8203;&#49884;&#44033;&#54868;&#54633;&#45768;&#45796;. . 이전 질문에서 식별한 상점의 위치를 ​​보여주는 지도를 만드십시오. . m_6 = folium.Map(location=[37,-120], zoom_start=6) # Show selected store locations mc = MarkerCluster() locations_of_interest = gpd.sjoin(starbucks_gdf, sel_counties) for idx, row in locations_of_interest.iterrows(): if not math.isnan(row[&#39;Longitude&#39;]) and not math.isnan(row[&#39;Latitude&#39;]): mc.add_child(folium.Marker([row[&#39;Latitude&#39;], row[&#39;Longitude&#39;]])) m_6.add_child(mc) . Make this Notebook Trusted to load map: File -&gt; Trust Notebook",
            "url": "https://kangsuin01.github.io/suin_blog/2022/05/20/first-map-exercise4.html",
            "relUrl": "/2022/05/20/first-map-exercise4.html",
            "date": " • May 20, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "kaggle - Geospatial Analysis02",
            "content": "Exercise: Coordinate Reference Systems . 소개 당신은 조류 보호 전문가이고 보라색 마틴의 이동 패턴을 이해하고자 합니다. 연구에서 이 새들은 일반적으로 미국 동부에서 여름 번식기를 보낸 다음 겨울 동안 남아메리카로 이주한다는 것을 발견했습니다. 그러나 이 새는 멸종 위기에 처해 있으므로 이 새가 방문할 가능성이 더 높은 위치를 자세히 살펴보고 싶습니다. . 남아메리카에는 이주(또는 거주)하는 종이 번성할 수 있는 최상의 기회를 보장하기 위해 특별 규정에 따라 운영되는 여러 보호 지역이 있습니다. 보라색 마틴이 이러한 지역을 방문하는 경향이 있는지 알고 싶습니다. 이 질문에 답하기 위해 11가지 다른 새의 연중 위치를 추적하는 최근 수집된 데이터를 사용할 것입니다. . import pandas as pd import geopandas as gpd from shapely.geometry import LineString . 2-1. &#45936;&#51060;&#53552; &#51069;&#50612;&#50724;&#44592; . birds_df = pd.read_csv(&quot;C:/Users/user/Desktop/강수인/archive/purple_martin.csv&quot;, parse_dates=[&#39;timestamp&#39;]) print(&quot;There are {} different birds in the dataset.&quot;.format(birds_df[&quot;tag-local-identifier&quot;].nunique())) birds_df.head() . There are 11 different birds in the dataset. . timestamp location-long location-lat tag-local-identifier . 0 2014-08-15 05:56:00 | -88.146014 | 17.513049 | 30448 | . 1 2014-09-01 05:59:00 | -85.243501 | 13.095782 | 30448 | . 2 2014-10-30 23:58:00 | -62.906089 | -7.852436 | 30448 | . 3 2014-11-15 04:59:00 | -61.776826 | -11.723898 | 30448 | . 4 2014-11-30 09:59:00 | -61.241538 | -11.612237 | 30448 | . 데이터 세트에는 11마리의 새가 있으며 각 새는 &quot;tag-local-identifier&quot; 열의 고유한 값으로 식별됩니다. 각 새는 일년 중 다른시기에 수집 된 여러 측정 값을 가지고 있습니다. . 새에는 (경도, 위도) 위치가 있는 Point 개체가 포함된 &quot;기하학&quot; 열과 함께 bird_df의 모든 열이 있어야 합니다. . 새의 CRS를 {&#39;init&#39;: &#39;epsg:4326&#39;}으로 설정합니다. . # birds_df에서 geometry정보를 가져오는데 location_long과 location_lat을 사용하겠다 birds = gpd.GeoDataFrame(birds_df, geometry=gpd.points_from_xy(birds_df[&quot;location-long&quot;], birds_df[&quot;location-lat&quot;])) # Set the CRS to {&#39;init&#39;: &#39;epsg:4326&#39;} birds.crs = {&#39;init&#39; :&#39;epsg:4326&#39;} . c: ProgramData Anaconda3 lib site-packages pyproj crs crs.py:130: FutureWarning: &#39;+init=&lt;authority&gt;:&lt;code&gt;&#39; syntax is deprecated. &#39;&lt;authority&gt;:&lt;code&gt;&#39; is the preferred initialization method. When making the change, be mindful of axis order changes: https://pyproj4.github.io/pyproj/stable/gotchas.html#axis-order-changes-in-proj-6 in_crs_string = _prepare_from_proj_string(in_crs_string) . 2-2. &#45936;&#51060;&#53552; &#54540;&#46991;&#54021; . 다음으로 GeoPandas에서 &#39;naturalearth_lowres&#39; 데이터 세트를 로드하고 Americas를 미주(북미 및 남미 모두)의 모든 국가 경계를 포함하는 GeoDataFrame으로 설정합니다. . world = gpd.read_file(gpd.datasets.get_path(&#39;naturalearth_lowres&#39;)) americas = world.loc[world[&#39;continent&#39;].isin([&#39;North America&#39;, &#39;South America&#39;])] americas.head() . pop_est continent name iso_a3 gdp_md_est geometry . 3 35623680 | North America | Canada | CAN | 1674000.0 | MULTIPOLYGON (((-122.84000 49.00000, -122.9742... | . 4 326625791 | North America | United States of America | USA | 18560000.0 | MULTIPOLYGON (((-122.84000 49.00000, -120.0000... | . 9 44293293 | South America | Argentina | ARG | 879400.0 | MULTIPOLYGON (((-68.63401 -52.63637, -68.25000... | . 10 17789267 | South America | Chile | CHL | 436100.0 | MULTIPOLYGON (((-68.63401 -52.63637, -68.63335... | . 16 10646714 | North America | Haiti | HTI | 19340.0 | POLYGON ((-71.71236 19.71446, -71.62487 19.169... | . (1)아메리카 GeoDataFrame의 국가 경계 및 (2)birds_gdf GeoDataFrame의 모든 점을 모두 표시하는 단일 플롯을 만듭니다. . ax = americas.plot(figsize = (10,10)) birds.plot(color = &#39;black&#39;,ax=ax, markersize = 2) . &lt;AxesSubplot:&gt; . 2-3. &#44033; &#49352;&#45716; &#50612;&#46356;&#50640;&#49436; &#50668;&#54665;&#51012; &#49884;&#51089;&#54616;&#44256; &#45149;&#45253;&#45768;&#44620;?(1&#48512;) . 이제 각 새의 경로를 더 자세히 볼 준비가 되었습니다. 다음 코드 셀을 실행하여 두 개의 GeoDataFrame을 만듭니다. . path_gdf에는 각 새의 경로를 표시하는 LineString 개체가 포함되어 있습니다. LineString() 메서드를 사용하여 Point 개체 목록에서 LineString 개체를 만듭니다. start_gdf에는 각 새의 시작점이 포함됩니다. . path_df = birds.groupby(&quot;tag-local-identifier&quot;)[&#39;geometry&#39;].apply(list).apply(lambda x: LineString(x)).reset_index() path_gdf = gpd.GeoDataFrame(path_df, geometry=path_df.geometry) path_gdf.crs = {&#39;init&#39; :&#39;epsg:4326&#39;} # GeoDataFrame showing starting point for each bird start_df = birds.groupby(&quot;tag-local-identifier&quot;)[&#39;geometry&#39;].apply(list).apply(lambda x: x[0]).reset_index() start_gdf = gpd.GeoDataFrame(start_df, geometry=start_df.geometry) start_gdf.crs = {&#39;init&#39; :&#39;epsg:4326&#39;} # Show first five rows of GeoDataFrame start_gdf.head() . c: ProgramData Anaconda3 lib site-packages pyproj crs crs.py:130: FutureWarning: &#39;+init=&lt;authority&gt;:&lt;code&gt;&#39; syntax is deprecated. &#39;&lt;authority&gt;:&lt;code&gt;&#39; is the preferred initialization method. When making the change, be mindful of axis order changes: https://pyproj4.github.io/pyproj/stable/gotchas.html#axis-order-changes-in-proj-6 in_crs_string = _prepare_from_proj_string(in_crs_string) c: ProgramData Anaconda3 lib site-packages pyproj crs crs.py:130: FutureWarning: &#39;+init=&lt;authority&gt;:&lt;code&gt;&#39; syntax is deprecated. &#39;&lt;authority&gt;:&lt;code&gt;&#39; is the preferred initialization method. When making the change, be mindful of axis order changes: https://pyproj4.github.io/pyproj/stable/gotchas.html#axis-order-changes-in-proj-6 in_crs_string = _prepare_from_proj_string(in_crs_string) . tag-local-identifier geometry . 0 30048 | POINT (-90.12992 20.73242) | . 1 30054 | POINT (-93.60861 46.50563) | . 2 30198 | POINT (-80.31036 25.92545) | . 3 30263 | POINT (-76.78146 42.99209) | . 4 30275 | POINT (-76.78213 42.99207) | . 각 새의 최종 위치를 포함하는 GeoDataFrame end_gdf를 만듭니다. . 형식은 두 개의 열(&quot;tag-local-identifier&quot; 및 &quot;geometry&quot;)이 있는 start_gdf의 형식과 동일해야 합니다. 여기서 &quot;geometry&quot; 열은 Point 개체를 포함합니다. end_gdf의 CRS를 {&#39;init&#39;: &#39;epsg:4326&#39;}으로 설정합니다. . end_df = birds.groupby(&quot;tag-local-identifier&quot;)[&#39;geometry&#39;].apply(list).apply(lambda x: x[-1]).reset_index() end_gdf = gpd.GeoDataFrame(end_df, geometry= end_df.geometry) end_gdf.crs = {&#39;init&#39;:&#39;epsg:4326&#39;} . c: ProgramData Anaconda3 lib site-packages pyproj crs crs.py:130: FutureWarning: &#39;+init=&lt;authority&gt;:&lt;code&gt;&#39; syntax is deprecated. &#39;&lt;authority&gt;:&lt;code&gt;&#39; is the preferred initialization method. When making the change, be mindful of axis order changes: https://pyproj4.github.io/pyproj/stable/gotchas.html#axis-order-changes-in-proj-6 in_crs_string = _prepare_from_proj_string(in_crs_string) . 2-4. &#44033; &#49352;&#45716; &#50612;&#46356;&#50640;&#49436; &#50668;&#54665;&#51012; &#49884;&#51089;&#54616;&#44256; &#45149;&#45253;&#45768;&#44620;?(2&#48512;) . 위의 GeoDataFrames(path_gdf, start_gdf 및 end_gdf)를 사용하여 단일 지도에서 모든 새의 경로를 시각화합니다. 미국 GeoDataFrame을 사용할 수도 있습니다. . ax = americas.plot(figsize = (10,10), color=&#39;white&#39;, linestyle=&#39;:&#39;, edgecolor=&#39;gray&#39;) path_gdf.plot(color = &#39;black&#39;,ax=ax, markersize = 20) start_gdf.plot(color = &quot;green&quot;, ax=ax, markersize = 20) end_gdf.plot(color = &quot;red&quot;,ax = ax, markersize = 20) . &lt;AxesSubplot:&gt; . 2-5. &#45224;&#50500;&#47700;&#47532;&#52852;&#51032; &#48372;&#54840;&#51648;&#50669;&#51008; &#50612;&#46356;&#51077;&#45768;&#44620;?(1&#48512;), &#47784;&#46304; &#49352;&#46308;&#51060; &#45224;&#50500;&#47700;&#47532;&#52852; &#50612;&#46360;&#44032;&#50640; &#51080;&#45716; &#44163;&#52376;&#47100; &#48372;&#51077;&#45768;&#45796;. &#44536;&#47084;&#45208; &#44536;&#46308;&#51008; &#48372;&#54840;&#44396;&#50669;&#51004;&#47196; &#44032;&#45208;&#50836;? . 남미의 모든 보호 지역 위치를 포함하는 GeoDataFrame protected_areas를 생성합니다. 해당 shapefile은 filepath protected_filepath에 있습니다. . protected_filepath = &quot;C:/Users/user/Desktop/강수인/archive/SAPA_Aug2019-shapefile/SAPA_Aug2019-shapefile/SAPA_Aug2019-shapefile-polygons.shp&quot; protected_areas = gpd.read_file(protected_filepath) . protected_areas.head() . WDPAID WDPA_PID PA_DEF NAME ORIG_NAME DESIG DESIG_ENG DESIG_TYPE IUCN_CAT INT_CRIT ... GOV_TYPE OWN_TYPE MANG_AUTH MANG_PLAN VERIF METADATAID SUB_LOC PARENT_ISO ISO3 geometry . 0 14067.0 | 14067 | 1 | Het Spaans Lagoen | Het Spaans Lagoen | Ramsar Site, Wetland of International Importance | Ramsar Site, Wetland of International Importance | International | Not Reported | Not Reported | ... | Not Reported | Not Reported | Not Reported | Management plan is not implemented and not ava... | State Verified | 1856 | Not Reported | NLD | ABW | POLYGON ((-69.97523 12.47379, -69.97523 12.473... | . 1 14003.0 | 14003 | 1 | Bubali Pond Bird Sanctuary | Bubali Pond Bird Sanctuary | Bird Sanctuary | Bird Sanctuary | National | Not Reported | Not Applicable | ... | Not Reported | Not Reported | Not Reported | Not Reported | State Verified | 1899 | Not Reported | NLD | ABW | POLYGON ((-70.04734 12.56329, -70.04615 12.563... | . 2 555624439.0 | 555624439 | 1 | Arikok National Park | Arikok National Park | National Park | National Park | National | Not Reported | Not Applicable | ... | Non-profit organisations | Non-profit organisations | Fundacion Parke Nacional Arikok | Not Reported | State Verified | 1899 | Not Reported | NLD | ABW | MULTIPOLYGON (((-69.96302 12.48384, -69.96295 ... | . 3 303894.0 | 303894 | 1 | Madidi | Madidi | Area Natural de Manejo Integrado | Natural Integrated Management Area | National | Not Reported | Not Applicable | ... | Federal or national ministry or agency | Not Reported | Not Reported | Not Reported | State Verified | 1860 | BO-L | BOL | BOL | POLYGON ((-68.59060 -14.43388, -68.59062 -14.4... | . 4 303893.0 | 303893 | 1 | Apolobamba | Apolobamba | Area Natural de Manejo Integado Nacional | National Natural Integrated Management Area | National | Not Reported | Not Applicable | ... | Federal or national ministry or agency | Not Reported | Not Reported | Not Reported | State Verified | 1860 | BO-L | BOL | BOL | POLYGON ((-69.20949 -14.73334, -69.20130 -14.7... | . 5 rows × 29 columns . 2-6. &#45224;&#50500;&#47700;&#47532;&#52852;&#51032; &#48372;&#54840;&#51648;&#50669;&#51008; &#50612;&#46356;&#51077;&#45768;&#44620;?(2&#48512;) . protected_areas GeoDataFrame을 사용하여 남아메리카의 보호 지역 위치를 표시하는 플롯을 만듭니다. (일부 보호 구역은 육지에 있고 다른 보호 구역은 바다에 있음을 알 수 있습니다.) . south_america = americas.loc[americas[&#39;continent&#39;]==&#39;South America&#39;] south_america.head() . pop_est continent name iso_a3 gdp_md_est geometry . 9 44293293 | South America | Argentina | ARG | 879400.0 | MULTIPOLYGON (((-68.63401 -52.63637, -68.25000... | . 10 17789267 | South America | Chile | CHL | 436100.0 | MULTIPOLYGON (((-68.63401 -52.63637, -68.63335... | . 20 2931 | South America | Falkland Is. | FLK | 281.8 | POLYGON ((-61.20000 -51.85000, -60.00000 -51.2... | . 28 3360148 | South America | Uruguay | URY | 73250.0 | POLYGON ((-57.62513 -30.21629, -56.97603 -30.1... | . 29 207353391 | South America | Brazil | BRA | 3081000.0 | POLYGON ((-53.37366 -33.76838, -53.65054 -33.2... | . ax = south_america.plot(figsize = (12,12), color = &quot;white&quot;, linestyle = &quot;:&quot;, edgecolor = &#39;gray&#39;) protected_areas.plot(color = &quot;black&quot;,ax = ax, alpha = 0.5) . &lt;AxesSubplot:&gt; . 2-7. &#45224;&#50500;&#47700;&#47532;&#52852;&#51032; &#47751; &#54140;&#49468;&#53944;&#44032; &#48372;&#54840;&#48155;&#44256; &#51080;&#49845;&#45768;&#44620;? &#45224;&#50500;&#47700;&#47532;&#52852;&#51032; &#47751; &#54140;&#49468;&#53944;&#44032; &#48372;&#54840;&#46104;&#45716;&#51648; &#54869;&#51064;&#54616;&#50668; &#45224;&#50500;&#47700;&#47532;&#52852;&#51032; &#50612;&#45712; &#48512;&#48516;&#51060; &#49352;&#50640;&#44172; &#51201;&#54633;&#54620;&#51648; &#50508;&#50500;&#48372;&#44192;&#49845;&#45768;&#45796;. . 첫 번째 단계로 남아메리카의 모든 보호 구역(해양 지역 제외)의 총 면적을 계산합니다. 이렇게 하려면 총 면적과 총 해양 면적을 각각 평방 킬로미터 단위로 포함하는 &quot;REP_AREA&quot; 및 &quot;REP_M_AREA&quot; 열을 사용합니다. . P_Area = sum(protected_areas[&#39;REP_AREA&#39;]-protected_areas[&#39;REP_M_AREA&#39;]) # 총면적에서 해양면적 빼준 것 같다 print(&quot;South America has {} square kilometers of protected areas.&quot;.format(P_Area)) . South America has 5396761.9116883585 square kilometers of protected areas. . south_america.head() . pop_est continent name iso_a3 gdp_md_est geometry . 9 44293293 | South America | Argentina | ARG | 879400.0 | MULTIPOLYGON (((-68.63401 -52.63637, -68.25000... | . 10 17789267 | South America | Chile | CHL | 436100.0 | MULTIPOLYGON (((-68.63401 -52.63637, -68.63335... | . 20 2931 | South America | Falkland Is. | FLK | 281.8 | POLYGON ((-61.20000 -51.85000, -60.00000 -51.2... | . 28 3360148 | South America | Uruguay | URY | 73250.0 | POLYGON ((-57.62513 -30.21629, -56.97603 -30.1... | . 29 207353391 | South America | Brazil | BRA | 3081000.0 | POLYGON ((-53.37366 -33.76838, -53.65054 -33.2... | . 다음 단계에 따라 남아메리카의 총 면적을 계산합니다. . 각 다각형의 면적 속성(CRS로 EPSG 3035 사용)을 사용하여 각 국가의 면적을 계산하고 결과를 합산합니다. 계산된 면적은 평방 미터 단위입니다. 평방 킬로미터 단위를 갖도록 답을 변환하십시오 . totalArea = sum(south_america.geometry.to_crs(epsg=3035).area) / 10**6 # 왜 3이 아니라 6인지 찾아보기 totalArea . 17759005.81506123 . percentage_protected = P_Area/totalArea print(&#39;Approximately {}% of South America is protected.&#39;.format(round(percentage_protected*100, 2))) . Approximately 30.39% of South America is protected. . &#45224;&#50500;&#47700;&#47532;&#52852;&#51032; &#49352;&#46308;&#51008; &#50612;&#46356;&#50640; &#51080;&#49845;&#45768;&#44620;? &#44536;&#47111;&#45796;&#47732; &#49352;&#46308;&#51008; &#48372;&#54840; &#44396;&#50669;&#50640; &#51080;&#49845;&#45768;&#44620;? . 모든 새, 남미에서 발견된 모든 위치를 보여주는 플롯을 만듭니다. 또한 남아메리카의 모든 보호 지역의 위치를 ​​표시합니다. . 순수 해양 지역(토지 구성 요소 없음)인 보호 지역을 제외하려면 &quot;MARINE&quot; 열을 사용할 수 있습니다(그리고 모든 행 대신 protected_areas[protected_areas[&#39;MARINE&#39;]!=&#39;2&#39;]의 행만 표시합니다. protected_areas GeoDataFrame에서). . marine_nan = protected_areas[protected_areas[&#39;MARINE&#39;]!=&#39;2&#39;] marine_nan.head() . WDPAID WDPA_PID PA_DEF NAME ORIG_NAME DESIG DESIG_ENG DESIG_TYPE IUCN_CAT INT_CRIT ... GOV_TYPE OWN_TYPE MANG_AUTH MANG_PLAN VERIF METADATAID SUB_LOC PARENT_ISO ISO3 geometry . 0 14067.0 | 14067 | 1 | Het Spaans Lagoen | Het Spaans Lagoen | Ramsar Site, Wetland of International Importance | Ramsar Site, Wetland of International Importance | International | Not Reported | Not Reported | ... | Not Reported | Not Reported | Not Reported | Management plan is not implemented and not ava... | State Verified | 1856 | Not Reported | NLD | ABW | POLYGON ((-69.97523 12.47379, -69.97523 12.473... | . 2 555624439.0 | 555624439 | 1 | Arikok National Park | Arikok National Park | National Park | National Park | National | Not Reported | Not Applicable | ... | Non-profit organisations | Non-profit organisations | Fundacion Parke Nacional Arikok | Not Reported | State Verified | 1899 | Not Reported | NLD | ABW | MULTIPOLYGON (((-69.96302 12.48384, -69.96295 ... | . 3 303894.0 | 303894 | 1 | Madidi | Madidi | Area Natural de Manejo Integrado | Natural Integrated Management Area | National | Not Reported | Not Applicable | ... | Federal or national ministry or agency | Not Reported | Not Reported | Not Reported | State Verified | 1860 | BO-L | BOL | BOL | POLYGON ((-68.59060 -14.43388, -68.59062 -14.4... | . 4 303893.0 | 303893 | 1 | Apolobamba | Apolobamba | Area Natural de Manejo Integado Nacional | National Natural Integrated Management Area | National | Not Reported | Not Applicable | ... | Federal or national ministry or agency | Not Reported | Not Reported | Not Reported | State Verified | 1860 | BO-L | BOL | BOL | POLYGON ((-69.20949 -14.73334, -69.20130 -14.7... | . 5 35.0 | 35 | 1 | Manuripi | Manuripi | Reserva Nacional de Vida Silvestre Amazónica | National Wildlife Reserve | National | Not Reported | Not Applicable | ... | Federal or national ministry or agency | Not Reported | Not Reported | Not Reported | State Verified | 1860 | BO-N | BOL | BOL | POLYGON ((-68.96744 -11.91783, -68.95988 -11.9... | . 5 rows × 29 columns . ax = south_america.plot(figsize = (20,20), color=&quot;white&quot;,linestyle = &quot;-&quot;, edgecolor = &quot;black&quot;) marine_nan.plot(color = &quot;yellow&quot;, ax = ax, alpha = 0.5) birds.plot(color = &#39;blue&#39;,ax=ax, markersize = 10) . &lt;AxesSubplot:&gt; .",
            "url": "https://kangsuin01.github.io/suin_blog/2022/05/20/first-map-exercise2.html",
            "relUrl": "/2022/05/20/first-map-exercise2.html",
            "date": " • May 20, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "kaggle - Geospatial Analysis01",
            "content": "Create interactive maps, and discover patterns in geospatial data. . Exercise : Your first map . import geopandas as gpd . 1. &#45936;&#51060;&#53552; &#44032;&#51256;&#50724;&#44592; . loans_filepath = &quot;C:/Users/user/Desktop/강수인/archive/kiva_loans/kiva_loans/kiva_loans.shp&quot; world_loans = gpd.read_file(loans_filepath) . 2. &#45936;&#51060;&#53552; &#54540;&#47215; &#44536;&#47532;&#44592; . world_filepath = gpd.datasets.get_path(&#39;naturalearth_lowres&#39;) # filepath알려주는 함수 world = gpd.read_file(world_filepath) world.head() . pop_est continent name iso_a3 gdp_md_est geometry . 0 920938 | Oceania | Fiji | FJI | 8374.0 | MULTIPOLYGON (((180.00000 -16.06713, 180.00000... | . 1 53950935 | Africa | Tanzania | TZA | 150600.0 | POLYGON ((33.90371 -0.95000, 34.07262 -1.05982... | . 2 603253 | Africa | W. Sahara | ESH | 906.5 | POLYGON ((-8.66559 27.65643, -8.66512 27.58948... | . 3 35623680 | North America | Canada | CAN | 1674000.0 | MULTIPOLYGON (((-122.84000 49.00000, -122.9742... | . 4 326625791 | North America | United States of America | USA | 18560000.0 | MULTIPOLYGON (((-122.84000 49.00000, -120.0000... | . ax = world.plot(figsize=(20,20)) world_loans.plot(ax=ax, markersize=2, color = &quot;black&quot;) . &lt;AxesSubplot:&gt; . 3) &#54596;&#47532;&#54592;&#50640; &#44592;&#48152;&#51012; &#46164; &#45824;&#52636; &#49440;&#53469;&#54616;&#44592; . world_loans.head() . Partner ID Field Part sector Loan Theme country amount geometry . 0 9 | KREDIT Microfinance Institution | General Financial Inclusion | Higher Education | Cambodia | 450 | POINT (102.89751 13.66726) | . 1 9 | KREDIT Microfinance Institution | General Financial Inclusion | Vulnerable Populations | Cambodia | 20275 | POINT (102.98962 13.02870) | . 2 9 | KREDIT Microfinance Institution | General Financial Inclusion | Higher Education | Cambodia | 9150 | POINT (102.98962 13.02870) | . 3 9 | KREDIT Microfinance Institution | General Financial Inclusion | Vulnerable Populations | Cambodia | 604950 | POINT (105.31312 12.09829) | . 4 9 | KREDIT Microfinance Institution | General Financial Inclusion | Sanitation | Cambodia | 275 | POINT (105.31312 12.09829) | . world_loans[world_loans[&#39;country&#39;]==&quot;Philippines&quot;] . Partner ID Field Part sector Loan Theme country amount geometry . 2859 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 400 | POINT (121.73961 17.64228) | . 2860 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 400 | POINT (121.74169 17.63235) | . 2861 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 400 | POINT (121.46667 16.60000) | . 2862 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 6050 | POINT (121.73333 17.83333) | . 2863 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 625 | POINT (121.51800 16.72368) | . ... ... | ... | ... | ... | ... | ... | ... | . 12376 389 | SEED Center Philippines | General Financial Inclusion | Small Enterprise | Philippines | 11500 | POINT (120.83841 14.35197) | . 12377 389 | SEED Center Philippines | General Financial Inclusion | General | Philippines | 17050 | POINT (120.83841 14.35197) | . 12378 389 | SEED Center Philippines | General Financial Inclusion | Small Enterprise | Philippines | 24000 | POINT (120.96597 14.62057) | . 12379 389 | SEED Center Philippines | General Financial Inclusion | General | Philippines | 31725 | POINT (120.96597 14.62057) | . 12380 389 | SEED Center Philippines | General Financial Inclusion | General | Philippines | 5725 | POINT (120.86138 14.28665) | . 3083 rows × 7 columns . phl_loans = world_loans[world_loans[&#39;country&#39;]==&quot;Philippines&quot;] phl_loans . Partner ID Field Part sector Loan Theme country amount geometry . 2859 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 400 | POINT (121.73961 17.64228) | . 2860 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 400 | POINT (121.74169 17.63235) | . 2861 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 400 | POINT (121.46667 16.60000) | . 2862 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 6050 | POINT (121.73333 17.83333) | . 2863 123 | Alalay sa Kaunlaran (ASKI) | General Financial Inclusion | General | Philippines | 625 | POINT (121.51800 16.72368) | . ... ... | ... | ... | ... | ... | ... | ... | . 12376 389 | SEED Center Philippines | General Financial Inclusion | Small Enterprise | Philippines | 11500 | POINT (120.83841 14.35197) | . 12377 389 | SEED Center Philippines | General Financial Inclusion | General | Philippines | 17050 | POINT (120.83841 14.35197) | . 12378 389 | SEED Center Philippines | General Financial Inclusion | Small Enterprise | Philippines | 24000 | POINT (120.96597 14.62057) | . 12379 389 | SEED Center Philippines | General Financial Inclusion | General | Philippines | 31725 | POINT (120.96597 14.62057) | . 12380 389 | SEED Center Philippines | General Financial Inclusion | General | Philippines | 5725 | POINT (120.86138 14.28665) | . 3083 rows × 7 columns . 4. &#54596;&#47532;&#54592;&#50640;&#49436; &#45824;&#52636;&#51012; &#50620;&#47560;&#45208; &#48155;&#45716;&#51648; &#54540;&#46991;&#54021;&#54644;&#48372;&#44592; . gpd.io.file.fiona.drvsupport.supported_drivers[&#39;KML&#39;] = &#39;rw&#39; #phl = gpd.read_file(&quot;C:/Users/Kangdaeyong/Desktop/datamining/kaggle_geospatial_analysis/archive/Philippines_AL258.kml&quot;, driver=&#39;KML&#39;) phl = gpd.read_file(&quot;C:/Users/user/Desktop/강수인/archive/Philippines_AL258.kml&quot;, driver=&#39;KML&#39;) #C:/Users/user/Desktop/강수인/archive phl.head() . Name Description geometry . 0 Autonomous Region in Muslim Mindanao | | MULTIPOLYGON (((119.46690 4.58718, 119.46653 4... | . 1 Bicol Region | | MULTIPOLYGON (((124.04577 11.57862, 124.04594 ... | . 2 Cagayan Valley | | MULTIPOLYGON (((122.51581 17.04436, 122.51568 ... | . 3 Calabarzon | | MULTIPOLYGON (((120.49202 14.05403, 120.49201 ... | . 4 Caraga | | MULTIPOLYGON (((126.45401 8.24400, 126.45407 8... | . ax = phl.plot(figsize = (13,13), color = &#39;none&#39;, edgecolor = &#39;gainsboro&#39;, zorder=3) phl_loans.plot(color = &#39;lightgreen&#39;,ax=ax, markersize = 2) . &lt;AxesSubplot:&gt; . Autonomous Region in Muslim Mindanao과 Bicol Region, Caraga이 다른 섬에 비해 대출 수가 적은 편이라서 이 지역에서 field partner를 구하면 좋을 것 같다 | 특히 가장 적은 Autonomous Region in Muslim Mindanao지역을 공략하는 것이 좋을 것으로 예상된다. | Cagayan Valley는 많은 편, Calabarzon도 적지 않게 대출받는 것으로 볼 수 있다. | .",
            "url": "https://kangsuin01.github.io/suin_blog/2022/05/20/first-map-exercise1.html",
            "relUrl": "/2022/05/20/first-map-exercise1.html",
            "date": " • May 20, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "matplotlib & seaborn packages task",
            "content": "코드 출처 - 이제현님 블로그 . https://jehyunlee.github.io/2020/09/30/Python-DS-34-seaborn_matplotlib/ | . matplotlib . import matplotlib . import matplotlib.pyplot as plt plt.plot([1, 2, 4, 9, 5, 3]) plt.show() . 그렇습니다. 데이터 몇 개로 plot 함수를 호출한 다음, show 함수를 호출해주면 간단히 그래프를 그려볼 수 있습니다! . plot 함수에 단일 배열의 데이터가 주어진다면, 수직 축의 좌표로서 이를 사용하게 되며, 각 데이터의 배열상 색인(인덱스)을 수평 좌표로서 사용합니다. 두 개의 배열을 넣어줄 수도 있습니다: 그러면, 하나는 x 축에 대한것이며, 다른 하나는 y 축에 대한것이 됩니다: . 같은 그림을 object oriented API를 이용해 그려보겠습니다. | object oriented API는 그래프의 각 부분을 객체로 지정하고 그리는 것으로, 다음과 같은 패턴을 가지고 있습니다. 아래 코드와 주석의 # object oriented API 부분은 이제현이 추가한 부분입니다. | object oriented API와 구분하기 위해 원본 코드에는 #pyplot이라는 헤더를 달았습니다.) | . fig, ax = plt.subplots() ax.plot([1,2,3,4,5]) fig # 도화지 . # fig = 종이, ax = 그림 fig, ax = plt.subplots() # 2. ax 위에 그래프를 그립니다. ax.plot([1, 2, 4, 9, 5, 3]) # 3. 그래프를 화면에 출력합니다. plt.show() . pyplot과 동일한 형태의 그래프가 그려집니다. | fig, ax를 선언하느라 한 줄을 더 입력해야 한다는 불편함이 있지만 ax 객체가 있어 그래프를 제어하기 더 쉬워집니다. | 많은 경우 fig, ax = plt.subplots() 대신 ax = plt.subplot()으로 해도 됩니다. | 그러나 fig 대상 명령(예. savefig)을 사용해야 할 때도 있고, 두 가지를 따로 외우려면 혼동이 되니 한 가지로 통일하는 것이 좋습니다. | . plt.plot([-3, -2, 5, 0], [1, 6, 4, 3]) # 앞쪽괄호가 x축, 뒷쪽이 y축 plt.show() . fig, ax = plt.subplots() ax.plot([-3, -2, 5, 0], [1, 6, 4, 3])# 앞쪽괄호가 x축, 뒷쪽이 y축 plt.show() . 이번에는 수학적인 함수를 그려보겠습니다. NumPy의 linespace 함수를 사용하여 -2 ~ 2 범위에 속하는 500개의 부동소수로 구성된 x 배열을 생성합니다. 그 다음 x의 각 값의 거듭제곱된 값을 포함하는 y 배열을 생성합니다 (NumPy에 대하여 좀 더 알고 싶다면, NumPy 튜토리얼을 참고하시기 바랍니다). . import numpy as np x = np.linspace(-2, 2, 500) # -2부터 2(포함)까지 500개로 나눈 것(포인트를 많이 나열해서 선같아보이는 것) y = x**2 plt.plot(x, y) plt.show() . fig, ax = plt.subplots() ax.plot(x, y) plt.show() . plt.plot(x, y) plt.title(&quot;Square function&quot;) # 상단 제목 plt.xlabel(&quot;x&quot;) # x축 제목 plt.ylabel(&quot;y = x**2&quot;) # y축 제목 plt.grid(True) # 격자무늬 plt.show() . object-oriented API는 축 이름과 같은 설정 명령어가 pyplot과 다소 다릅니다. | 대체로 축 이름(label), 범위(limits) 등을 지정하는 명령어는 set_대상(), 거꾸로 그래프에서 설정값을 가져오는 명령어는 get_대상()으로 통일되어 있습니다. | 개인적으로 pyplot의 명령어 체계보다 object-oriented API의 체계를 선호합니다. | . fig, ax = plt.subplots() # 위와 비슷하지만 plt.이 아닌 ax.set_을 이용해 그래프를 커스텀할 수 있다 ax.plot(x, y) ax.set_title(&quot;Square function&quot;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y = x**2&quot;) ax.grid(True) plt.show() . &#49440;&#51032; &#49828;&#53440;&#51068;&#44284; &#49353;&#49345; . 기본적으로 matplotlib은 바로 다음에 위치한(연이은) 데이터 사이에 선을 그립니다 . # 위에서와 마찬가지로 앞쪽이 x축, 뒷쪽이 y축 plt.plot([0, 100, 100, 0, 0, 100, 50, 0, 100], [0, 0, 100, 100, 0, 100, 130, 100, 0]) plt.axis([-10, 110, -10, 140]) # x,y축의 범위를 지정 plt.show() . fig, ax = plt.subplots() # 위와 동일, 앞쪽이 x축, 뒷쪽이 y축 ax.plot([0, 100, 100, 0, 0, 100, 50, 0, 100], [0, 0, 100, 100, 0, 100, 130, 100, 0]) ax.set_xlim(-10, 110) # 최소 최대 지정 ax.set_ylim(-10, 140) # 최소 최대 지정 # 그래프의 범위는 pyplot과 같이 ax.axis([-10, 110, -10, 140]) 으로 지정할 수 있습니다. # 하지만 위와 같이 set_xlim, set_ylim을 사용해서 명시하는 것이 더 체계적으로 느껴집니다. plt.show() . 세 번째 파라미터를 지정하면 선의 스타일과 색상을 바꿀 수 있습니다. 예를 들어서 &quot;g--&quot;는 &quot;초록색 파선&quot;을 의미합니다. 예를 들어 아래와 같이 말이죠: . # &quot;r-&quot; 앞에 있는 좌표로 빨간 실선을 그리고 # &quot;g--&quot;앞에 있는 좌표로 초록 점선을 그려준다 plt.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], &quot;r-&quot;, [0, 100, 50, 0, 100], [0, 100, 130, 100, 0], &quot;g--&quot;) plt.axis([-10, 110, -10, 140]) # x,y축 설정 plt.show() . fig, ax = plt.subplots() # &quot;r-&quot; 앞에 있는 좌표로 빨간 실선을 그리고 # &quot;g--&quot;앞에 있는 좌표로 초록 점선을 그려준다 ax.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], &quot;r-&quot;, [0, 100, 50, 0, 100], [0, 100, 130, 100, 0], &quot;g--&quot;) ax.set_xlim(-10, 110) # x축 범위 설정 ax.set_ylim(-10, 140) # y축 범위 설정 plt.show() . 또는 show를 호출하기 전 plot을 여러번 호출해도 가능합니다. . # 여러 개의 그림을 한번에 나타내기 plt.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], &quot;r-&quot;) plt.plot([0, 100, 50, 0, 100], [0, 100, 130, 100, 0], &quot;g--&quot;) plt.axis([-10, 110, -10, 140]) plt.show() . fig, ax = plt.subplots() ax.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], &quot;r-&quot;) ax.plot([0, 100, 50, 0, 100], [0, 100, 130, 100, 0], &quot;g--&quot;) ax.set_xlim(-10, 110) ax.set_ylim(-10, 140) plt.show() . 선 대신에 간단한 점을 그려보는 것도 가능합니다. 아래는 초록색 파선, 빨강 점선, 파랑 삼각형의 예를 보여줍니다. 공식 문서에서 사용 가능한 스타일 및 색상의 모든 옵션을 확인해 볼 수 있습니다. . x = np.linspace(-1.4, 1.4, 30) # -1.4,1.4를 포함하며 그 사이의 값을 30개로 나눠서그림 plt.plot(x, x, &#39;g--&#39;, x, x**2, &#39;r:&#39;, x, x**3, &#39;b^&#39;) # g--앞의 것을 초록실선으로 , r:앞에 있는 것을 빨간 점이 이어지 모양으로, b^앞에 있는 것을 파란 삼각형이 이어지게 그려준다 plt.show() . fig, ax = plt.subplots() x = np.linspace(-1.4, 1.4, 30) # -1.4부터 1.4(포함)를 30개로 나눠라 ax.plot(x, x, &#39;g--&#39;) # x값을 이용하여 ax.plot(x, x**2, &#39;r:&#39;) ax.plot(x, x**3, &#39;b^&#39;) # 여러 그래프를 ax.plot(x, x, &#39;g--&#39;, x, x**2, &#39;r:&#39;, x, x**3, &#39;b^&#39;)과 같이 한 줄에 그릴 수도 있습니다. # 그러나 이와 같이 따로 떼서 그리면 혼동을 방지할 수 있습니다. # 이는 pyplot도 마찬가지입니다. plt.show() . plot 함수는 Line2D객체로 구성된 리스트를 반환합니다 (각 객체가 각 선에 대응됩니다). 이 선들에 대한 추가적인 속성을 설정할 수도 있습니다. 가령 선의 두께, 스타일, 투명도 같은것의 설정이 가능합니다. 공식 문서에서 설정 가능한 모든 속성을 확인해볼 수 있습니다. . x = np.linspace(-1.4, 1.4, 30) line1, line2, line3 = plt.plot(x, x, &#39;g--&#39;, x, x**2, &#39;r:&#39;, x, x**3, &#39;b^&#39;) line1.set_linewidth(3.0) # 더 두껍게 해준듯 line1.set_dash_capstyle(&quot;round&quot;) # 대쉬 스타일을 바꿔서 둥글둥글한 모양으로 바꿈 line3.set_alpha(0.2) # 투명도 plt.show() . x = np.linspace(-1.4, 1.4, 30) fig, ax = plt.subplots() # plot을 나누어 그리면 어디에 어떤 설정이 적용되었는지 알아보기 편합니다. # linewidth, alpha와 같은 line style도 plot() 안에 넣으면 혼동을 방지할 수 있습니다. line1 = ax.plot(x, x, &#39;g--&#39;, linewidth=3, dash_capstyle=&#39;round&#39;) # 위에보다 선이 굵어지고 모양이 더 동글동글 해짐 대시 스타일을 round로 바꿨기 때문 line2 = ax.plot(x, x**2, &#39;r:&#39;) line3 = ax.plot(x, x**3, &#39;b^&#39;, alpha=0.2) # 투명도 추가 plt.show() . &#44536;&#47548; &#51200;&#51109; . 그래프를 그림파일로 저장하는 방법은 간단합니다. 단순히 파일이름을 지정하여 savefig 함수를 호출해 주기만 하면 됩니다. 가능한 이미지 포맷은 사용하는 그래픽 백엔드에 따라서 지원 여부가 결정됩니다. . x = np.linspace(-1.4, 1.4, 30) plt.plot(x, x**2) plt.savefig(&quot;my_square_function.png&quot;, transparent=True) # 저장, transparent = True는 배경을 투명하게 한다는 뜻 . &#48512;&#48516; &#44536;&#47000;&#54532; (subplot) . matplotlib는 하나의 그림(figure)에 여러개의 부분 그래프를 포함할 수 있습니다. 이 부분 그래프는 격자 형식으로 관리됩니다. subplot 함수를 호출하여 부분 그래프를 생성할 수 있습니다. 이 때 격자의 행/열의 수 및 그래프를 그리고자 하는 부분 그래프의 색인을 파라미터로서 지정해줄 수 있습니다 (색인은 1부터 시작하며, 좌-&gt;우, 상단-&gt;하단의 방향입니다). . pyplot은 현재 활성화된 부분 그래프를 계속해서 추적합니다 (plt.gca()를 호출하여 해당 부분 그래프의 참조를 얻을 수 있습니다). 따라서, plot 함수를 호출할 때 활성화된 부분 그래프에 그림이 그려지게 됩니다. | . object oriented API 방식에서는 그래프를 그리기 전에 먼저 틀을 잡아둡니다. 그래프를 그릴 때 사전에 정의된 영역 중 어디에 그래프를 그릴지 지정하는 방식입니다. | pyplot의 plt.gca()가 바로 object oriented API의 axes입니다. | . x = np.linspace(-1.4, 1.4, 30) # subplot(2,2,1)은 subplot(221)로 축약할 수 있습니다. plt.subplot(2, 2, 1) # 2 행 2 열 크기의 격자 중 첫 번째 부분 그래프 = 좌측 상단 plt.plot(x, x) plt.subplot(2, 2, 2) # 2 행 2 열 크기의 격자 중 두 번째 부분 그래프 = 우측 상단 plt.plot(x, x**2) plt.subplot(2, 2, 3) # 2 행 2 열 크기의 격자 중 세 번째 부분 그래프 = 좌측 하단 plt.plot(x, x**3) plt.subplot(2, 2, 4) # 2 행 2 열 크기의 격자 중 네 번째 부분 그래프 = 우측 하단 plt.plot(x, x**4) plt.show() . x = np.linspace(-1.4, 1.4, 30) fig, ax = plt.subplots(2, 2) # 순서대로 row의 갯수, col의 갯수입니다. nrows=2, cols=2로 지정할 수도 있습니다. # plot위치는 ax[row, col] 또는 ax[row][col]로 지정합니다. ax[0, 0].plot(x, x) # 2 행 2 열 크기의 격자 중 첫 번째 부분 그래프 = 좌측 상단 ax[0, 1].plot(x, x**2) # 2 행 2 열 크기의 격자 중 두 번째 부분 그래프 = 우측 상단 ax[1, 0].plot(x, x**3) # 2 행 2 열 크기의 격자 중 세 번째 부분 그래프 = 좌측 하단 ax[1, 1].plot(x, x**4) # 2 행 2 열 크기의 격자 중 네 번째 부분 그래프 = 우측 하단 plt.show() . 격자의 여러 영역으로 확장된 부분 그래프를 생성하는 것도 쉽습니다: . # 밑에 2개 열을 차지하는 부분 주의하기 line8에 쓰여져 있는 주석 읽고 잘 이해하기 plt.subplot(2, 2, 1) # 2 행 2 열 크기의 격자 중 첫 번째 부분 그래프 = 좌측 상단 plt.plot(x, x) plt.subplot(2, 2, 2) # 2 행 2 열 크기의 격자 중 두 번째 부분 그래프 = 우측 상단 plt.plot(x, x**2) plt.subplot(2, 1, 2) # 2행 *1* 열의 두 번째 부분 그래프 = 하단 # 2행 1열 크기의 그래프가 두 개 그려질 수 있지만, # 상단 부분은 이미 두 개의 부분 그래프가 차지하였다. # 따라서, 두 번째 부분 그래프로 지정함 plt.plot(x, x**3) plt.show() . grid = plt.GridSpec(2, 2) # 2행 2열 크기의 격?자를 준비합니다. ax1 = plt.subplot(grid[0, 0]) # 2행 2열 크기의 격자 중 첫 번째 부분 그래프 = 좌측 상단 ax2 = plt.subplot(grid[0, 1]) # 2행 2열 크기의 격자 중 두 번째 부분 그래프 = 우측 상단 ax3 = plt.subplot(grid[1, 0:]) # 2행 *1*열의 두 번째 부분 그래프 = 하단 # 범위를 [1, 0:]으로 설정하여 2행 전체를 지정함. ax1.plot(x, x) ax2.plot(x, x**2) ax3.plot(x, x**3) plt.show() . 보다 복잡한 부분 그래프의 위치 선정이 필요하다면, subplot2grid를 대신 사용할 수 있습니다. 격자의 행과 열의 번호 및 격자에서 해당 부분 그래프를 그릴 위치를 지정해줄 수 있습니다 (좌측상단 = (0,0). 또한 몇 개의 행/열로 확장되어야 하는지도 추가적으로 지정할 수 있습니다. 아래는 그에 대한 예를 보여줍니다: . # 그림 그리면서 보여주신 것 # rowspan = 2라면 행방향으로 2칸, colspan=2라면 열 방향으로 2칸 plt.subplot2grid((3,3), (0, 0), rowspan=2, colspan=2) # 3x3 매트릭스에서 0행0열에 해당하는 자리에서 rowspan과 colspan이 모두 2로 0행0열을 기준으로 2x2매트릭스만큼 자치하겠다는 뜻 plt.plot(x, x**2) plt.subplot2grid((3,3), (0, 2)) # 3x3 매트릭스에서 0행2열에 해당하는 자리에 그림(rowspan이나 colspan을 따로 지정하지 않을 때는 해당 칸만 씀) plt.plot(x, x**3) plt.subplot2grid((3,3), (1, 2), rowspan=2) # 3x3 매트릭스에서 1행2열에 해당하는 자리에서 rowspan = 2니까 1행2열과 2행2열에 해당 그래프를 그림 plt.plot(x, x**4) plt.subplot2grid((3,3), (2, 0), colspan=2) # 3x3 매트릭스에서 2행0열에 해당하는 자리에서 colspan = 2니까 2행 0열과 2행 1열을 자치하게 그래프 그림 plt.plot(x, x**5) plt.show() . gridsize = (3, 3) # 2행 2열 크기의 격자를 준비합니다. ax1 = plt.subplot2grid(gridsize, (0,0), rowspan=2, colspan=2) ax2 = plt.subplot2grid(gridsize, (0,2)) ax3 = plt.subplot2grid(gridsize, (1,2), rowspan=2) ax4 = plt.subplot2grid(gridsize, (2,0), colspan=2) ax1.plot(x, x**2) ax2.plot(x, x**3) ax3.plot(x, x**4) ax4.plot(x, x**5) plt.show() . 보다 유연한 부분그래프 위치선정이 필요하다면, GridSpec 문서를 확인해 보시길 바랍니다. . &#50668;&#47084;&#44060;&#51032; &#44536;&#47548; (figure) . 여러개의 그림을 그리는것도 가능합니다. 각 그림은 하나 이상의 부분 그래프를 가질 수 있습니다. 기본적으로는 matplotlib이 자동으로 figure(1)을 생성합니다. 그림간 전환을 할 때, pyplot은 현재 활성화된 그림을 계속해서 추적합니다 (이에대한 참조는 plt.gcf()의 호출로 알 수 있습니다). 또한 활성화된 그림의 활성화된 부분 그래프가 현재 그래프가 그려질 부분 그래프가 됩니다. . object oriented API에서는 실행 순이 아니라 객체를 중심으로 명령을 실행합니다. | 다른 그림을 그리다가 앞서 그림을 추가할 때 pyplot에서 plt.figure() 명령으로 위 그림을 호출하는 대신 object oriented API는 목표 Axes를 지정하여 추가합니다. | . x = np.linspace(-1.4, 1.4, 30) plt.figure(1) plt.subplot(211) #plt.subplot(211)는 plt.subplot(2,1,1)와 같다 plt.plot(x, x**2) plt.title(&quot;Square and Cube&quot;) plt.subplot(212) plt.plot(x, x**3) plt.figure(2, figsize=(10, 5)) plt.subplot(121) plt.plot(x, x**4) plt.title(&quot;y = x**4&quot;) plt.subplot(122) plt.plot(x, x**5) plt.title(&quot;y = x**5&quot;) plt.figure(1) # 그림 1로 돌아가며, 활성화된 부분 그래프는 212 (하단)이 됩니다********* plt.plot(x, -x**3, &quot;r:&quot;) plt.show() . x = np.linspace(-1.4, 1.4, 30) fig1, ax1 = plt.subplots(nrows=2, ncols=1) ax1[0].plot(x, x**2) ax1[0].set_title(&quot;Square and Cube&quot;) ax1[1].plot(x, x**3) fig2, ax2 = plt.subplots(nrows=1, ncols=2, figsize=(10, 5)) ax2[0].plot(x, x**4) ax2[0].set_title(&quot;y = x**4&quot;) ax2[1].plot(x, x**5) ax2[1].set_title(&quot;y = x**5&quot;) ax1[1].plot(x, -x**3, &quot;r:&quot;) # 그림 1로 돌아가며, 활성화된 부분 그래프는 ax1[1] (하단)이 됩니다. plt.show() . 여기서 설명하는 부분은 matplotlib의 object oriented API(객체지향 인터페이스)입니다. | . x = np.linspace(-2, 2, 200) fig1, (ax_top, ax_bottom) = plt.subplots(2, 1, sharex=True) fig1.set_size_inches(10,5) line1, line2 = ax_top.plot(x, np.sin(3*x**2), &quot;r-&quot;, x, np.cos(5*x**2), &quot;b-&quot;) # line1은 파란색 선, line2는 빨간색 여기까지 그리면 맨 위에 그림 만들어짐 line3, = ax_bottom.plot(x, np.sin(3*x), &quot;r-&quot;) # 두 번째 그래프 (빨간색) ax_top.grid(True) fig2, ax = plt.subplots(1, 1) # 맨 마지막 그래프 (하늘색) ax.plot(x, x**2) plt.show() . 일관성을 위해서 이 튜토리얼의 나머지 부분에서는 pyplot의 상태 머신을 계속해서 사용할 것입니다. 그러나 프로그램에서는 객체지향 인터페이스의 사용을 권장하고 싶습니다. . Pylab vs Pyplot vs Matplotlib . pylab, pyplot, matplotlib 간의 관계에대한 혼동이 있습니다. 그러나 이들의 관계는 매우 단순합니다: matplotlib은 완전한 라이브러리이며, pylab 및 pyplot을 포함한 모든것을 가지고 있습니다. . Pyplot은 그래프를 그리기위한 다양한 도구를 제공합니다. 여기에는 내부적인 객체지향적인 그래프 그리기 라이브러리에 대한 상태 머신 인터페이스도 포함됩니다. . Pylab은 mkatplotlib.pyplot 및 NumPy를 단일 네임스페이스로 임포트하는 편리성을 위한 모듈입니다. 인터넷에 떠도는 pylab을 사용하는 여러 예제를 보게 될 것입니다. 그러나 이는 더이상 권장되는 사용방법은 아닙니다 (왜냐하면 명시적인 임포트가 암시적인것 보다 더 낫기 때문입니다). . Pylab, Pyplot, Object oriented API의 관계는 여기를 참고하십시오 | . &#53581;&#49828;&#53944; &#44536;&#47532;&#44592; . text 함수를 호출하여 텍스트를 그래프의 원하는 위치에 추가할 수 있습니다. 출력을 원하는 텍스트와 수평 및 수직 좌표를 지정하고, 추가적으로 몇 가지 속성을 지정해 주기만 하면 됩니다. matplotlib의 모든 텍스트는 TeX 방정식 표현을 포함할 수 있습니다. 더 자세한 내용은 공식 문서를 참조하시기 바랍니다. . x = np.linspace(-1.5, 1.5, 30) px = 0.8 py = px**2 plt.plot(x, x**2, &quot;b-&quot;, px, py, &quot;ro&quot;) # 여기서 점을 찍음, 그래프 선은 파란색으로 하고 좌표px,py에 (빨간)점을 찍는 코드 plt.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;blue&#39;, horizontalalignment=&quot;center&quot;) plt.text(px - 0.08, py, &quot;Beautiful point&quot;, ha=&quot;right&quot;, weight=&quot;heavy&quot;) plt.text(px, py, &quot;x = %0.2f ny = %0.2f&quot;%(px, py), rotation=50, color=&#39;gray&#39;) plt.show() . fig, ax = plt.subplots() ax.plot(x, x**2, &quot;b-&quot;) # x축은 x, y축은 x**2 따라서 y=x**2를 그린다 ax.plot(px, py, &quot;ro&quot;) # 점 찍힘 ax.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;blue&#39;, horizontalalignment=&quot;center&quot;) ax.text(px - 0.08, py, &quot;Beautiful point&quot;, ha=&quot;right&quot;, weight=&quot;heavy&quot;) ax.text(px, py, &quot;x = %0.2f ny = %0.2f&quot;%(px, py), rotation=50, color=&#39;gray&#39;) plt.show() . 알아둘 것: ha는 horizontalalignment(수평정렬)의 이명 입니다. | . 더 많은 텍스트 속성을 알고 싶다면, 공식 문서를 참조하시기 바랍니다. . 아래 그래프의 &quot;beautiful point&quot; 같은 텍스트 처럼, 그래프의 요소에 주석을 다는것은 꽤 흔한 일입니다. annotate 함수는 이를 쉽게 할 수 있게 해 줍니다: 관심있는 부분의 위치를 지정하고, 텍스트의 위치를 지정합니다. 그리고 텍스트 및 화살표에 대한 추가적인 속성도 지정해줄 수 있습니다. . plt.plot(x, x**2, px, py, &quot;ro&quot;) plt.annotate(&quot;Beautiful point&quot;, xy=(px, py), xytext=(px-1.3,py+0.5), color=&quot;green&quot;, weight=&quot;heavy&quot;, fontsize=14, arrowprops={&quot;facecolor&quot;: &quot;lightgreen&quot;}) plt.show() . fig, ax = plt.subplots() ax.plot(x, x**2, px, py, &quot;ro&quot;) ax.annotate(&quot;Beautiful point&quot;, xy=(px, py), xytext=(px-1.3,py+0.5), color=&quot;green&quot;, weight=&quot;heavy&quot;, fontsize=14, arrowprops={&quot;facecolor&quot;: &quot;lightgreen&quot;}) plt.show() . bbox 속성을 사용하면, 텍스트를 포함하는 사각형을 그려볼 수도 있습니다: . # 빨간점 plt.plot(x, x**2, px, py, &quot;ro&quot;) # 화살표 부분 bbox_props = dict(boxstyle=&quot;rarrow,pad=0.3&quot;, ec=&quot;b&quot;, lw=2, fc=&quot;lightblue&quot;) plt.text(px-0.2, py, &quot;Beautiful point&quot;, bbox=bbox_props, ha=&quot;right&quot;) # 네모 박스 부분 bbox_props = dict(boxstyle=&quot;round4,pad=1,rounding_size=0.2&quot;, ec=&quot;black&quot;, fc=&quot;#EEEEFF&quot;, lw=5) plt.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;black&#39;, ha=&quot;center&quot;, bbox=bbox_props) plt.show() . fig, ax = plt.subplots() ax.plot(x, x**2) ax.plot(px, py, &quot;ro&quot;) bbox_props = dict(boxstyle=&quot;rarrow,pad=0.3&quot;, ec=&quot;b&quot;, lw=2, fc=&quot;lightblue&quot;) # 화살표 부분 ax.text(px-0.2, py, &quot;Beautiful point&quot;, bbox=bbox_props, ha=&quot;right&quot;) bbox_props = dict(boxstyle=&quot;round4,pad=1,rounding_size=0.2&quot;, ec=&quot;black&quot;, fc=&quot;#EEEEFF&quot;, lw=5) # 네모 박스 부분 ax.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;black&#39;, ha=&quot;center&quot;, bbox=bbox_props) plt.show() . 재미를 위해서 xkcd 스타일의 그래프를 그려보고 싶다면, with plt.xkcd() 섹션 블록을 활용할 수도 있습니다: . with plt.xkcd(): plt.plot(x, x**2, px, py, &quot;ro&quot;) bbox_props = dict(boxstyle=&quot;rarrow,pad=0.3&quot;, ec=&quot;b&quot;, lw=2, fc=&quot;lightblue&quot;) plt.text(px-0.2, py, &quot;Beautiful point&quot;, bbox=bbox_props, ha=&quot;right&quot;) bbox_props = dict(boxstyle=&quot;round4,pad=1,rounding_size=0.2&quot;, ec=&quot;black&quot;, fc=&quot;#EEEEFF&quot;, lw=5) plt.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;black&#39;, ha=&quot;center&quot;, bbox=bbox_props) plt.show() . &#48276;&#47168; (Legends) . 범례를 추가하는 가장 간단한 방법은 모든 선에 라벨을 설정 해 주고, legend 함수를 호출하는 것입니다. . x = np.linspace(-1.4, 1.4, 50) plt.plot(x, x**2, &quot;r--&quot;, label=&quot;Square function&quot;) plt.plot(x, x**3, &quot;g-&quot;, label=&quot;Cube function&quot;) plt.legend(loc=&quot;best&quot;) plt.grid(True) plt.show() . x = np.linspace(-1.4, 1.4, 50) fig, ax = plt.subplots() ax.plot(x, x**2, &quot;r--&quot;, label=&quot;Square function&quot;) ax.plot(x, x**3, &quot;g-&quot;, label=&quot;Cube function&quot;) ax.legend(loc=&quot;best&quot;) ax.grid(True) plt.show() . &#48708;&#49440;&#54805; &#52377;&#46020; . Matplotlib은 로그, 로짓(logit)과 같은 비선형 척도를 지원합니다. . # 로그그래프 그릴줄 알아야함 x = np.linspace(0.1, 15, 500) y = x**3/np.exp(2*x) plt.figure(1) plt.plot(x, y) plt.yscale(&#39;linear&#39;) plt.title(&#39;linear&#39;) plt.grid(True) plt.figure(2) plt.plot(x, y) plt.yscale(&#39;log&#39;) plt.title(&#39;log&#39;) plt.grid(True) plt.figure(3) plt.plot(x, y) plt.yscale(&#39;logit&#39;) plt.title(&#39;logit&#39;) plt.grid(True) plt.figure(4) plt.plot(x, y - y.mean()) plt.yscale(&#39;symlog&#39;, linthreshy=0.05) plt.title(&#39;symlog&#39;) plt.grid(True) plt.show() . TypeError Traceback (most recent call last) c: Users user Desktop 강수인 2022-05-13-matplotlib-seaborn-kangsuin.ipynb Cell 65&#39; in &lt;cell line: 27&gt;() &lt;a href=&#39;vscode-notebook-cell:/c%3A/Users/user/Desktop/%EA%B0%95%EC%88%98%EC%9D%B8/2022-05-13-matplotlib-seaborn-kangsuin.ipynb#ch0000117?line=24&#39;&gt;25&lt;/a&gt; plt.figure(4) &lt;a href=&#39;vscode-notebook-cell:/c%3A/Users/user/Desktop/%EA%B0%95%EC%88%98%EC%9D%B8/2022-05-13-matplotlib-seaborn-kangsuin.ipynb#ch0000117?line=25&#39;&gt;26&lt;/a&gt; plt.plot(x, y - y.mean()) &gt; &lt;a href=&#39;vscode-notebook-cell:/c%3A/Users/user/Desktop/%EA%B0%95%EC%88%98%EC%9D%B8/2022-05-13-matplotlib-seaborn-kangsuin.ipynb#ch0000117?line=26&#39;&gt;27&lt;/a&gt; plt.yscale(&#39;symlog&#39;, linthreshy=0.05) &lt;a href=&#39;vscode-notebook-cell:/c%3A/Users/user/Desktop/%EA%B0%95%EC%88%98%EC%9D%B8/2022-05-13-matplotlib-seaborn-kangsuin.ipynb#ch0000117?line=27&#39;&gt;28&lt;/a&gt; plt.title(&#39;symlog&#39;) &lt;a href=&#39;vscode-notebook-cell:/c%3A/Users/user/Desktop/%EA%B0%95%EC%88%98%EC%9D%B8/2022-05-13-matplotlib-seaborn-kangsuin.ipynb#ch0000117?line=28&#39;&gt;29&lt;/a&gt; plt.grid(True) File c: ProgramData Anaconda3 lib site-packages matplotlib pyplot.py:3055, in yscale(value, **kwargs) &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/pyplot.py?line=3052&#39;&gt;3053&lt;/a&gt; @_copy_docstring_and_deprecators(Axes.set_yscale) &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/pyplot.py?line=3053&#39;&gt;3054&lt;/a&gt; def yscale(value, **kwargs): -&gt; &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/pyplot.py?line=3054&#39;&gt;3055&lt;/a&gt; return gca().set_yscale(value, **kwargs) File c: ProgramData Anaconda3 lib site-packages matplotlib axes _base.py:4108, in _AxesBase.set_yscale(self, value, **kwargs) &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axes/_base.py?line=4105&#39;&gt;4106&lt;/a&gt; g = self.get_shared_y_axes() &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axes/_base.py?line=4106&#39;&gt;4107&lt;/a&gt; for ax in g.get_siblings(self): -&gt; &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axes/_base.py?line=4107&#39;&gt;4108&lt;/a&gt; ax.yaxis._set_scale(value, **kwargs) &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axes/_base.py?line=4108&#39;&gt;4109&lt;/a&gt; ax._update_transScale() &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axes/_base.py?line=4109&#39;&gt;4110&lt;/a&gt; ax.stale = True File c: ProgramData Anaconda3 lib site-packages matplotlib axis.py:761, in Axis._set_scale(self, value, **kwargs) &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axis.py?line=758&#39;&gt;759&lt;/a&gt; def _set_scale(self, value, **kwargs): &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axis.py?line=759&#39;&gt;760&lt;/a&gt; if not isinstance(value, mscale.ScaleBase): --&gt; &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axis.py?line=760&#39;&gt;761&lt;/a&gt; self._scale = mscale.scale_factory(value, self, **kwargs) &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axis.py?line=761&#39;&gt;762&lt;/a&gt; else: &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/axis.py?line=762&#39;&gt;763&lt;/a&gt; self._scale = value File c: ProgramData Anaconda3 lib site-packages matplotlib scale.py:597, in scale_factory(scale, axis, **kwargs) &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/scale.py?line=594&#39;&gt;595&lt;/a&gt; scale = scale.lower() &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/scale.py?line=595&#39;&gt;596&lt;/a&gt; scale_cls = _api.check_getitem(_scale_mapping, scale=scale) --&gt; &lt;a href=&#39;file:///c%3A/ProgramData/Anaconda3/lib/site-packages/matplotlib/scale.py?line=596&#39;&gt;597&lt;/a&gt; return scale_cls(axis, **kwargs) TypeError: __init__() got an unexpected keyword argument &#39;linthreshy&#39; . &#54001;&#44284; &#54001;&#52964; (Ticks and tickers) . 각 축에는 &quot;틱(ticks)&quot;이라는 작은 표시가 있습니다. 정확히 말하자면, &quot;틱&quot;은 표시(예. (-1, 0, 1))의 위치&quot;이며, 틱 선은 그 위치에 그려지는 작은 선입니다. 또한 &quot;틱 라벨&quot;은 틱 선 옆에 그려지는 라벨이며, &quot;틱커&quot;는 틱의 위치를 결정하는 객체 입니다. 기본적인 틱커는 ~5 에서 8 틱을 위치시키는데 꽤 잘 작동합니다. 즉, 틱 서로간에 적당한 거리를 표현합니다. . 하지만, 가끔은 좀 더 이를 제어할 필요가 있습니다 (예. 위의 로짓 그래프에서는 너무 많은 틱 라벨이 있습니다). 다행히도 matplotlib은 틱을 완전히 제어하는 방법을 제공합니다. 심지어 보조 눈금(minor tick)을 활성화 할 수도 있습니다. . # 이제현 주: 사실상 object oriented API 입니다. x = np.linspace(-2, 2, 100) plt.figure(1, figsize=(15,10)) plt.subplot(131) plt.plot(x, x**3) plt.grid(True) plt.title(&quot;Default ticks&quot;) ax = plt.subplot(132) plt.plot(x, x**3) ax.xaxis.set_ticks(np.arange(-2, 2, 1)) plt.grid(True) plt.title(&quot;Manual ticks on the x-axis&quot;) ax = plt.subplot(133) plt.plot(x, x**3) plt.minorticks_on() ax.tick_params(axis=&#39;x&#39;, which=&#39;minor&#39;, bottom=&#39;off&#39;) ax.xaxis.set_ticks([-2, 0, 1, 2]) ax.yaxis.set_ticks(np.arange(-5, 5, 1)) ax.yaxis.set_ticklabels([&quot;min&quot;, -4, -3, -2, -1, 0, 1, 2, 3, &quot;max&quot;]) plt.title(&quot;Manual ticks and tick labels n(plus minor ticks) on the y-axis&quot;) plt.grid(True) plt.show() . # 위 pyplot 예제는 사실상 object oriented API 입니다. # 여기에서는 같은 기능을 더 단순한 코드로 구현하였습니다 x = np.linspace(-2, 2, 100) fig, ax = plt.subplots(ncols=3, figsize=(15, 10)) ax[0].plot(x, x**3) ax[0].grid(True) ax[0].set_title(&quot;Default ticks&quot;) ax[1].plot(x, x**3) ax[1].grid(True) ax[1].set_xticks(np.arange(-2, 2, 1)) ax[1].set_title(&quot;Manual ticks on the x-axis&quot;) ax[2].plot(x, x**3) ax[2].grid(True) ax[2].minorticks_on() ax[2].set_xticks([-2, 0, 1, 2], minor=False) ax[2].set_yticks(np.arange(-5, 5, 1)) ax[2].set_yticklabels([&quot;min&quot;, -4, -3, -2, -1, 0, 1, 2, 3, &quot;max&quot;]) ax[2].set_title(&quot;Manual ticks and tick labels n(plus minor ticks) on the y-axis&quot;) plt.show() . &#44537;&#51340;&#54364;&#44228;&#51032; &#53804;&#50689; (Polar projection) . 극좌표계 그래프를 그리는 것은 매우 간단합니다. 부분 그래프를 생성할 때 projection 속성을 &quot;polar&quot;로 설정해 주기만 하면 됩니다. . object oriented API는 일반적으로 plt.subplots()로 Figure와 Axes 객체를 동시에 생성합니다. | plt.subplots()는 projection 속성을 가지고 있지 않습니다. | 따라서 projection을 사용할 때는 plt.figure()로 Figure 객체를 먼저 생성한 후 plt.subplot()이나 plt.add_subplot()으로 Axes 객체를 추가해 주거나, fig.subplots() 안에 subplot_kw=={&#39;polar&#39;:True}로 지정해 주어야 합니다. | . radius = 1 theta = np.linspace(0, 2*np.pi*radius, 1000) plt.subplot(111, projection=&#39;polar&#39;) plt.plot(theta, np.sin(5*theta), &quot;g-&quot;) plt.plot(theta, 0.5*np.cos(20*theta), &quot;b-&quot;) plt.show() . radius = 1 theta = np.linspace(0, 2*np.pi*radius, 1000) fig = plt.figure() ax = fig.add_subplot(projection=&#39;polar&#39;) # 또는, subplot_kw 를 이용해서 polar plot으로 설정합니다. # fig, ax = plt.subplots(subplot_kw={&#39;polar&#39;:True}) ax.plot(theta, np.sin(5*theta), &quot;g-&quot;) ax.plot(theta, 0.5*np.cos(20*theta), &quot;b-&quot;) plt.show() . 3&#52264;&#50896; &#53804;&#50689; . 3차원 그래프를 그리는것은 꽤 간단합니다. 우선 &quot;3d&quot; 투영을 등록하는 Axes3D를 임포트 해줘야 합니다. 그리곤 projection 속성을 &quot;3d&quot;로 설정된 부분 그래프 생성합니다. 그러면 Axes3DSubplot 이라는 객체가 반환되는데, 이 객체의 plot_surface 메서드를 호출하면 x, y, z 좌표를 포함한 추가적이나 속성을 지정할 수 있습니다. . # 사실상 object oriented API 입니다. from mpl_toolkits.mplot3d import Axes3D x = np.linspace(-5, 5, 50) y = np.linspace(-5, 5, 50) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) figure = plt.figure(1, figsize = (12, 4)) subplot3d = plt.subplot(111, projection=&#39;3d&#39;) # Axes 객체입니다. surface = subplot3d.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=matplotlib.cm.coolwarm, linewidth=0.1) plt.show() . 동일한 데이터를 출력하는 또 다른 방법은 등고선도(contour plot)를 이용하는 것입니다. . plt.contourf(X, Y, Z, cmap=matplotlib.cm.coolwarm) plt.colorbar() plt.show() . # 이제현 주: 종종 object oriented API가 pyplot보다 불편할 때가 있습니다. # contour plot의 colorbar는 무엇을 대상으로 할 지를 인자로 전달해야 합니다. fig, ax = plt.subplots() contour = ax.contourf(X, Y, Z, cmap=matplotlib.cm.coolwarm) plt.colorbar(contour) plt.show() . &#49328;&#51216;&#46020;(Scatter plot) . 단순히 각 점에 대한 x 및 y 좌표를 제공하면 산점도를 그릴 수 있습니다. . from numpy.random import rand x, y = rand(2, 100) plt.scatter(x, y) plt.show() . from numpy.random import rand x, y = rand(2, 100) fig, ax = plt.subplots() ax.scatter(x, y) plt.show() . 부수적으로 각 점의 크기를 정할 수도 있습니다. . x, y, scale = rand(3, 100) scale = 500 * scale ** 5 plt.scatter(x, y, s=scale) plt.show() . x, y, scale = rand(3, 100) scale = 500 * scale ** 5 fig, ax = plt.subplots() ax.scatter(x, y, s=scale) plt.show() . 마찬가지로 여러 속성을 설정할 수 있습니다. 가령 테두리 및 모양의 내부 색상, 그리고 투명도와 같은것의 설정이 가능합니다. . # 점이 300개 찍힘 n=100이고 루프를 3번돌리기 때문 for color in [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]: n = 100 x, y = rand(2, n) scale = 500.0 * rand(n) ** 5 plt.scatter(x, y, s=scale, c=color, alpha=0.3, edgecolors=&#39;blue&#39;) plt.grid(True) plt.show() . fig, ax = plt.subplots() for color in [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]: n = 100 x, y = rand(2, n) scale = 500.0 * rand(n) ** 5 ax.scatter(x, y, s=scale, c=color, alpha=0.3, edgecolors=&#39;blue&#39;) ax.grid(True) plt.show() . &#49440; . 지금까지 해온것 처럼 plot 함수를 사용하여 선을 그릴 수 있습니다. 하지만, 가끔은 그래프를 통과하는 무한한 선을 그리는 유틸리티 함수를 만들면 편리합니다 (기울기와 절편으로). 또한 hlines 및 vlines 함수를 사용하면, 아래와 같이 부분 수평 및 수직 선을 그릴 수도 있습니다: . from numpy.random import randn def plot_line(axis, slope, intercept, **kargs): xmin, xmax = axis.get_xlim() plt.plot([xmin, xmax], [xmin*slope+intercept, xmax*slope+intercept], **kargs) # x값은[xmin, xmax], y값은[xmin*slope+intercept, xmax*slope+intercept] x = randn(1000) y = 0.5*x + 5 + randn(1000)*2 plt.axis([-2.5, 2.5, -5, 15]) plt.scatter(x, y, alpha=0.2) plt.plot(1, 0, &quot;ro&quot;) plt.vlines(1, -5, 0, color=&quot;red&quot;) # 수직선 plt.hlines(0, -2.5, 1, color=&quot;red&quot;) # 수평선 plot_line(axis=plt.gca(), slope=0.5, intercept=5, color=&quot;magenta&quot;) plt.grid(True) plt.show() . from numpy.random import randn # Axis를 인자로 전달하여 함수 연산과 시각화를 수행합니다. def plot_line(axis, slope, intercept, **kargs): xmin, xmax = axis.get_xlim() axis.plot([xmin, xmax], [xmin*slope+intercept, xmax*slope+intercept], **kargs) x = randn(1000) y = 0.5*x + 5 + randn(1000)*2 fig, ax = plt.subplots() ax.set_xlim(-2.5, 2.5) ax.set_ylim(-5, 15) ax.scatter(x, y, alpha=0.2) ax.plot(1, 0, &quot;ro&quot;) ax.vlines(1, -5, 0, color=&quot;red&quot;) ax.hlines(0, -2.5, 1, color=&quot;red&quot;) plot_line(axis=ax, slope=0.5, intercept=5, color=&quot;magenta&quot;) ax.grid(True) plt.show() . &#55176;&#49828;&#53664;&#44536;&#47016; . data = [1, 1.1, 1.8, 2, 2.1, 3.2, 3, 3, 3, 3] plt.subplot(211) plt.hist(data, bins = 10, rwidth=0.8) plt.subplot(212) plt.hist(data, bins = [1, 1.5, 2, 2.5, 3], rwidth=0.95) plt.xlabel(&quot;Value&quot;) plt.ylabel(&quot;Frequency&quot;) plt.show() . data = [1, 1.1, 1.8, 2, 2.1, 3.2, 3, 3, 3, 3] fig, ax = plt.subplots(2, 1) ax[0].hist(data, bins = 10, rwidth=0.8) ax[1].hist(data, bins = [1, 1.5, 2, 2.5, 3], rwidth=0.95) ax[1].set_xlabel(&quot;Value&quot;) ax[1].set_ylabel(&quot;Frequency&quot;) plt.show() . data1 = np.random.randn(400) data2 = np.random.randn(500) + 3 data3 = np.random.randn(450) + 6 data4a = np.random.randn(200) + 9 data4b = np.random.randn(100) + 10 plt.hist(data1, bins=5, color=&#39;g&#39;, alpha=0.75, label=&#39;bar hist&#39;) # default histtype=&#39;bar&#39; plt.hist(data2, color=&#39;b&#39;, alpha=0.65, histtype=&#39;stepfilled&#39;, label=&#39;stepfilled hist&#39;) plt.hist(data3, color=&#39;r&#39;, histtype=&#39;step&#39;, label=&#39;step hist&#39;) plt.hist((data4a, data4b), color=(&#39;r&#39;,&#39;m&#39;), alpha=0.55, histtype=&#39;barstacked&#39;, label=(&#39;barstacked a&#39;, &#39;barstacked b&#39;)) plt.xlabel(&quot;Value&quot;) plt.ylabel(&quot;Frequency&quot;) plt.legend() plt.grid(True) plt.show() . data1 = np.random.randn(400) data2 = np.random.randn(500) + 3 data3 = np.random.randn(450) + 6 data4a = np.random.randn(200) + 9 data4b = np.random.randn(100) + 10 fig, ax = plt.subplots() ax.hist(data1, bins=5, color=&#39;g&#39;, alpha=0.75, label=&#39;bar hist&#39;) # default histtype=&#39;bar&#39; ax.hist(data2, color=&#39;b&#39;, alpha=0.65, histtype=&#39;stepfilled&#39;, label=&#39;stepfilled hist&#39;) ax.hist(data3, color=&#39;r&#39;, histtype=&#39;step&#39;, label=&#39;step hist&#39;) ax.hist((data4a, data4b), color=(&#39;r&#39;,&#39;m&#39;), alpha=0.55, histtype=&#39;barstacked&#39;, label=(&#39;barstacked a&#39;, &#39;barstacked b&#39;)) ax.set_xlabel(&quot;Value&quot;) ax.set_ylabel(&quot;Frequency&quot;) ax.legend() ax.grid(True) plt.show() . &#51060;&#48120;&#51648; . matplotlib에서의 이미지 불러오기, 생성하기, 화면에 그리기는 꽤 간단합니다. . 이미지를 불러오려면 matplotlib.image 모듈을 임포트하고, 파일이름을 지정한 imread 함수를 호출해 주면 됩니다. 그러면 이미지 데이터가 NumPy의 배열로서 반환됩니다. 앞서 저장했던 my_square_function.png 이미지에 대하여 이를 수행해 보겠습니다. . 이미지 단독 출력은 pyplot과 object oriented API 사이에 별 차이가 없습니다. | Axes를 지정해서 출력하는 것이 다를 뿐입니다. | pyplot과의 중복성이 강하지만 익숙해지는 차원에서 object oriented API를 함께 도시합니다. | . import matplotlib.image as mpimg img = mpimg.imread(&#39;my_square_function.png&#39;) print(img.shape, img.dtype) . (288, 432, 4) float32 . 288x432 크기의 이미지를 불러왔습니다. 각 픽셀은 0~1 사이의 32비트 부동소수 값인 4개의 요소(빨강, 초록, 파랑, 투명도)로 구성된 배열로 표현됩니다. 이번에는 imshow함수를 호출해 보겠습니다: . plt.imshow(img) plt.show() . fig, ax = plt.subplots() ax.imshow(img) plt.show() . 이미지 출력에 포함된 축을 숨기고 싶다면 아래와 같이 축을 off 시켜줄 수 있습니다: . plt.imshow(img) plt.axis(&#39;off&#39;) plt.show() . fig, ax = plt.subplots() ax.imshow(img) ax.axis(&#39;off&#39;) plt.show() . 여러분만의 이미지를 생성하는것도 마찬가지로 간단합니다: . img = np.arange(100*100).reshape(100, 100) print(img) plt.imshow(img) plt.show() . [[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]] . img = np.arange(100*100).reshape(100, 100) print(img) fig, ax = plt.subplots() ax.imshow(img) plt.show() . [[ 0 1 2 ... 97 98 99] [ 100 101 102 ... 197 198 199] [ 200 201 202 ... 297 298 299] ... [9700 9701 9702 ... 9797 9798 9799] [9800 9801 9802 ... 9897 9898 9899] [9900 9901 9902 ... 9997 9998 9999]] . RGB 수준을 제공하지 않는다면, imshow 함수는 자동으로 값을 색그래디언트에 매핑합니다. 기본적인 동작에서의 색그래디언트는 파랑(낮은 값) 에서 빨강(높은 값)으로 움직입니다. 하지만 아래와 같이 다른 색상맵을 선택할 수도 있습니다: . plt.imshow(img, cmap=&quot;hot&quot;) plt.show() . fig, ax = plt.subplots() ax.imshow(img, cmap=&quot;hot&quot;) plt.show() . RGB 이미지를 직접적으로 생성하는것 또한 가능합니다: . img = np.empty((20,30,3)) img[:, :10] = [0, 0, 0.6] img[:, 10:20] = [1, 1, 1] img[:, 20:] = [0.6, 0, 0] plt.imshow(img, interpolation=&#39;bilinear&#39;) plt.show() . img = np.empty((20,30,3)) img[:, :10] = [0, 0, 0.6] img[:, 10:20] = [1, 1, 1] img[:, 20:] = [0.6, 0, 0] fig, ax = plt.subplots() ax.imshow(img, interpolation=&#39;bilinear&#39;) plt.show() . img 배열이 매우 작기 때문에 (20x30), imshow 함수는 이미지를 figure 크기에 맞도록 늘려버린채 출력합니다. 이러한 늘리기의 기본 동작은 쌍선형 보간법(bilinear interpolation)을 사용하여 추가된 픽셀을 매꿉니다. 테두리가 흐릿한 이유입니다. . 다른 보간법 알고리즘을 선택할 수도 있습니다. 가령 아래와 같이 근접 픽셀을 복사하는 방법이 있습니다: . 위 코드의 ax.imshow(img, interpolation=&#39;bilinear&#39;) 부분은 원문에서 ax.imshow(img)로 되어 있습니다. | matplotlib 2.0 이전에는 interpolation=&#39;bilinear&#39;가 기본값이기 때문에 경계선이 흐려지는 문제가 있었습니다. | 그러나 이후 interpolation=&#39;nearest&#39;로 기본값이 변경되어 흐려지는 문제가 더 이상 발생하지 않습니다. | 자세한 사항은 이 글을 참고하십시오. | . plt.imshow(img, interpolation=&quot;nearest&quot;) plt.show() . fig, ax = plt.subplots() ax.imshow(img, interpolation=&quot;nearest&quot;) plt.show() . &#50528;&#45768;&#47700;&#51060;&#49496; . matplotlib은 이미지 생성에 주로 사용되지만, 애니메이션의 출력도 가능합니다. 우선 matplotlib.animation을 임포트 해 줘야 합니다. 그 다음은 (주피터 노트북에서) nbagg를 백엔드로 설정하거나, 아래의 코드를 실행해 주면 됩니다. . import matplotlib.animation as animation matplotlib.rc(&#39;animation&#39;, html=&#39;jshtml&#39;) . 다음의 예는 데이터를 생성하는것으로 시작됩니다. 그 다음, 빈 그래프를 생성하고, 애니메이션을 그릴 매 프레임 마다 호출될 갱신(update) 함수를 정의합니다. 마지막으로, FuncAnimation 인스턴스를 생성하여 그래프에 애니메이션을 추가합니다. . FuncAnimation 생성자는 figure, 갱신 함수, 그 외의 파라미터를 수용합니다. 각 프레임간 20ms의 시간차가 있는 100개의 프레임으로 구성된 애니메이션에 대한 인스턴스를 만들었습니다. 애니메이션의 각 프레임마다 FuncAnimation 는 갱신 함수를 호출하고, 프레임 번호를 num (이 예에서는 0~99의 범위) 으로서 전달해 줍니다. 또한 갱신 함수의 추가적인 두 파라미터는 FuncAnimation 생성시 fargs에 넣어준 값이 됩니다. . 작성한 갱신 함수는 선을 구성하는 데이터를 0 ~ num 데이터로 설정합니다 (따라서 데이터가 점진적으로 그려집니다). 그리고 약간의 재미 요소를 위해서, 각 데이터에 약간의 무작위 수를 추가하여 선이 씰룩씰룩 움직이게끔 해 주었습니다. . x = np.linspace(-1, 1, 100) y = np.sin(x**2*25) data = np.array([x, y]) fig = plt.figure() line, = plt.plot([], [], &quot;r-&quot;) # start with an empty plot plt.axis([-1.1, 1.1, -1.1, 1.1]) plt.plot([-0.5, 0.5], [0, 0], &quot;b-&quot;, [0, 0], [-0.5, 0.5], &quot;b-&quot;, 0, 0, &quot;ro&quot;) plt.grid(True) plt.title(&quot;Marvelous animation&quot;) # this function will be called at every iteration def update_line(num, data, line): line.set_data(data[..., :num] + np.random.rand(2, num) / 25) # we only plot the first `num` data points. return line, line_ani = animation.FuncAnimation(fig, update_line, frames=100, fargs=(data, line), interval=67) plt.close() line_ani . &lt;/input&gt; Once Loop Reflect x = np.linspace(-1, 1, 100) y = np.sin(x**2*25) data = np.array([x, y]) fig, ax = plt.subplots() line, = ax.plot([], [], &quot;r-&quot;) # start with an empty plot ax.set_xlim(-1.1, 1.1) ax.set_ylim(-1.1, 1.1) ax.plot([-0.5, 0.5], [0, 0], &quot;b-&quot;, [0, 0], [-0.5, 0.5], &quot;b-&quot;, 0, 0, &quot;ro&quot;) ax.grid(True) ax.set_title(&quot;Marvelous animation&quot;) # this function will be called at every iteration def update_line(num, data, line): line.set_data(data[..., :num] + np.random.rand(2, num) / 25) # we only plot the first `num` data points. return line, line_ani = animation.FuncAnimation(fig, update_line, frames=100, fargs=(data, line), interval=67) plt.close() line_ani . &lt;/input&gt; Once Loop Reflect seaborn . import seaborn as sns sns.set() sns.set(style=&quot;darkgrid&quot;) import numpy as np import pandas as pd # importing matplotlib import matplotlib.pyplot as plt %matplotlib inline import warnings warnings.filterwarnings(&quot;ignore&quot;) plt.rcParams[&#39;figure.figsize&#39;]=(10,10) . data_BM = pd.read_csv(&#39;bigmart_data.csv&#39;) # drop the null values data_BM = data_BM.dropna(how=&quot;any&quot;) # multiply Item_Visibility by 100 to increase size data_BM[&quot;Visibility_Scaled&quot;] = data_BM[&quot;Item_Visibility&quot;] * 100 # view the top results data_BM.head() . Item_Identifier Item_Weight Item_Fat_Content Item_Visibility Item_Type Item_MRP Outlet_Identifier Outlet_Establishment_Year Outlet_Size Outlet_Location_Type Outlet_Type Item_Outlet_Sales Visibility_Scaled . 0 FDA15 | 9.300 | Low Fat | 0.016047 | Dairy | 249.8092 | OUT049 | 1999 | Medium | Tier 1 | Supermarket Type1 | 3735.1380 | 1.604730 | . 1 DRC01 | 5.920 | Regular | 0.019278 | Soft Drinks | 48.2692 | OUT018 | 2009 | Medium | Tier 3 | Supermarket Type2 | 443.4228 | 1.927822 | . 2 FDN15 | 17.500 | Low Fat | 0.016760 | Meat | 141.6180 | OUT049 | 1999 | Medium | Tier 1 | Supermarket Type1 | 2097.2700 | 1.676007 | . 4 NCD19 | 8.930 | Low Fat | 0.000000 | Household | 53.8614 | OUT013 | 1987 | High | Tier 3 | Supermarket Type1 | 994.7052 | 0.000000 | . 5 FDP36 | 10.395 | Regular | 0.000000 | Baking Goods | 51.4008 | OUT018 | 2009 | Medium | Tier 3 | Supermarket Type2 | 556.6088 | 0.000000 | . 1. &#44592;&#48376; &#54540;&#47215; &#47564;&#46308;&#44592; . matplotlib에서 여러 줄이 필요한 한 줄로 seaborn에서 몇 가지 기본 플롯을 만드는 방법을 살펴보겠습니다. . &#46972;&#51064; &#52264;&#53944; . 일부 데이터 세트의 경우 한 변수의 변화를 시간의 함수로 이해하거나 이와 유사한 연속 변수를 이해하고 싶을 수 있습니다. | seaborn에서 이는 lineplot() 함수로 직접 또는 kind=&quot;line&quot;을 설정하여 relplot()으로 수행할 수 있습니다. | . sns.lineplot(x=&quot;Item_Weight&quot;, y=&quot;Item_MRP&quot;,data=data_BM[:50]); . &#47561;&#45824; &#52264;&#53944; . Seaborn에서는 barplot 기능을 이용하여 간단하게 막대그래프를 생성할 수 있습니다. | matplotlib에서 동일한 결과를 얻으려면 데이터 범주를 현명하게 그룹화하기 위해 추가 코드를 작성해야 했습니다. | 그리고 나서 플롯이 올바르게 나오도록 훨씬 더 많은 코드를 작성해야 했습니다. | . sns.barplot(x=&quot;Item_Type&quot;, y=&quot;Item_MRP&quot;, data=data_BM[:5]) . &lt;AxesSubplot:xlabel=&#39;Item_Type&#39;, ylabel=&#39;Item_MRP&#39;&gt; . &#55176;&#49828;&#53664;&#44536;&#47016; . distplot()을 사용하여 Seaborn에서 히스토그램을 생성할 수 있습니다. 사용할 수 있는 여러 옵션이 있으며 노트북에서 더 자세히 살펴보겠습니다. | . sns.distplot(data_BM[&#39;Item_MRP&#39;]) . &lt;AxesSubplot:xlabel=&#39;Item_MRP&#39;, ylabel=&#39;Density&#39;&gt; . &#49345;&#51088; &#54540;&#47215; . Seaborn에서 boxplot을 생성하기 위해 boxplot()을 사용할 수 있습니다. | 아이템의 Item_Outlet_Sales 분포를 시각화해 봅시다. | . sns.boxplot(data_BM[&#39;Item_Outlet_Sales&#39;], orient=&#39;vertical&#39;) # 2000에 몰려있음, 오른쪽으로 긴 꼬리를 가지는 분포 . &lt;AxesSubplot:xlabel=&#39;Item_Outlet_Sales&#39;&gt; . &#48148;&#51060;&#50732;&#47536; &#54540;&#47215; . 바이올린 플롯은 상자 및 whisker 플롯과 유사한 역할을 합니다. | 이러한 분포를 비교할 수 있도록 하나(또는 그 이상) 범주형 변수의 여러 수준에 걸친 정량적 데이터의 분포를 보여줍니다. | 모든 플롯 구성 요소가 실제 데이터 포인트에 해당하는 상자 플롯과 달리 바이올린 플롯은 기본 분포의 커널 밀도 추정을 특징으로 합니다. | Seaborn에서 violinplot()을 사용하여 바이올린 플롯을 만들 수 있습니다. | . sns.violinplot(data_BM[&#39;Item_Outlet_Sales&#39;], orient=&#39;vertical&#39;, color=&#39;magenta&#39;) . &lt;AxesSubplot:xlabel=&#39;Item_Outlet_Sales&#39;&gt; . scatter plot(&#49328;&#51216;&#46020;) . 각 포인트는 데이터 세트의 관찰을 나타내는 포인트 클라우드를 사용하여 두 변수의 분포를 나타냅니다. | 이 묘사를 통해 눈은 그들 사이에 의미 있는 관계가 있는지 여부에 대한 상당한 양의 정보를 추론할 수 있습니다. | relplot()을 kind=scatter 옵션과 함께 사용하여 seaborn에서 산점도를 그릴 수 있습니다. | . 참고: 여기에서는 플롯에 대한 데이터의 하위 집합만 사용할 것입니다. . sns.relplot(x=&quot;Item_MRP&quot;, y=&quot;Item_Outlet_Sales&quot;, data=data_BM[:200], kind=&quot;scatter&quot;); . Hue semantic(&#49353;&#51312; &#51032;&#48120;) . 세 번째 변수에 따라 점을 색칠하여 플롯에 다른 차원을 추가할 수도 있습니다. Seaborn에서는 이것을 &quot;색조 의미론&quot; 사용이라고 합니다. . sns.relplot(x=&quot;Item_MRP&quot;, y=&quot;Item_Outlet_Sales&quot;, hue=&quot;Item_Type&quot;,data=data_BM[:200]); . hue(색조) 의미 체계를 사용하면 seaborn에서 더 복잡한 선 플롯을 만들 수 있습니다. . 다음 예에서는 Outlet_Size의 다른 범주에 대해 다른 선 플롯이 만들어집니다. | . sns.lineplot(x=&quot;Item_Weight&quot;, y=&quot;Item_MRP&quot;,hue=&#39;Outlet_Size&#39;,data=data_BM[:150]); . Bubble plot(&#48260;&#48660; &#54540;&#47215;) . hue(색조) 시맨틱을 활용하여 Item_Visibility별로 거품을 색칠함과 동시에 개별 거품의 크기로 사용합니다. | . sns.relplot(x=&quot;Item_MRP&quot;, y=&quot;Item_Outlet_Sales&quot;, data=data_BM[:200], kind=&quot;scatter&quot;, size=&quot;Visibility_Scaled&quot;, hue=&quot;Visibility_Scaled&quot;); . &#52852;&#53580;&#44256;&#47532;&#48324; &#54616;&#50948; &#54540;&#47215; . Seaborn에서 카테고리별 플롯을 생성할 수도 있습니다. | 각 Outlet_Size에 대한 산점도를 만들었습니다 | . sns.relplot(x=&quot;Item_Weight&quot;, y=&quot;Item_Visibility&quot;,hue=&#39;Outlet_Size&#39;,style=&#39;Outlet_Size&#39;,col=&#39;Outlet_Size&#39;,data=data_BM[:100]); # hue로 컬러 설정 # ggplot에서도 비슷한 함수 있음 . 2. seaborn&#51032; &#44256;&#44553; &#48276;&#51452;&#54805; &#54540;&#47215; . 범주형 변수의 경우 seaborn에 세 가지 다른 패밀리가 있습니다. . 범주형 산점도: . stripplot() (kind=&quot;strip&quot; 사용, 기본값) | swarmplot() (종류=&quot;swarm&quot; 포함) | . | 범주 분포도: . boxplot() (종류=&quot;box&quot; 포함) | 바이올린플롯() (종류=&quot;바이올린&quot; 포함) | boxenplot() (종류=&quot;boxen&quot; 사용) | . | 범주 추정 플롯: . pointplot() (종류=&quot;포인트&quot; 사용) | barplot() (종류=&quot;막대&quot; 사용) | . | . catplot()에서 데이터의 기본 표현은 산점도를 사용합니다. . a. &#48276;&#51452;&#54805; &#49328;&#51216;&#46020; . &#49828;&#53944;&#47549; &#54540;&#47215; . 하나의 변수가 범주형인 산점도를 그립니다. | catplot()에서 kind=strip을 전달하여 생성할 수 있습니다. | . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;, kind=&#39;strip&#39;,data=data_BM[:250]); . &#49828;&#50908; &#54540;&#47215; . 이 함수는 stripplot()과 유사하지만 포인트가 겹치지 않도록 조정됩니다(범주 축을 따라만). | 이것은 값의 분포를 더 잘 표현하지만 많은 수의 관찰에 대해서는 잘 확장되지 않습니다. 이러한 스타일의 플롯은 때때로 &quot;꿀벌&quot;이라고 불립니다. | catplot()에서 kind=swarm을 전달하여 생성할 수 있습니다. | . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;, kind=&#39;swarm&#39;,data=data_BM[:250]); . b. &#48276;&#51452;&#54805; &#48516;&#54252;&#46020; . &#49345;&#51088; &#44536;&#47548; . 상자 그림은 극단값과 함께 분포의 3사분위수 값을 보여줍니다. | &quot;수염&quot;은 하위 및 상위 사분위수의 1.5 IQR 내에 있는 점으로 확장되며, 이 범위를 벗어나는 관찰은 독립적으로 표시됩니다. | 이것은 상자 그림의 각 값이 데이터의 실제 관측값에 해당함을 의미합니다. | . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;box&quot;,data=data_BM); . Violin Plots . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;violin&quot;,data=data_BM); . boxplot . 이 스타일의 플롯은 &quot;문자 값&quot;으로 정의되는 많은 수의 분위수를 보여주기 때문에 원래 &quot;문자 값&quot; 플롯이라고 명명되었습니다. | 모든 특징이 실제 관찰과 일치하는 분포의 비모수적 표현을 플로팅하는 상자 플롯과 유사합니다. | 더 많은 분위수를 표시함으로써 특히 꼬리 부분의 분포 모양에 대한 더 많은 정보를 제공합니다. | . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;boxen&quot;,data=data_BM); . Point plot . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;point&quot;,data=data_BM); . Bar plots . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;bar&quot;,data=data_BM); . 3. Density Plots . 히스토그램 대신 Seaborn이 sn.kdeplot으로 수행하는 커널 밀도 추정을 사용하여 분포를 원활하게 추정할 수 있습니다. . plt.figure(figsize=(10,10)) sns.kdeplot(data_BM[&#39;Item_Visibility&#39;], shade=True); . plt.figure(figsize=(10,10)) sns.kdeplot(data_BM[&#39;Item_MRP&#39;], shade=True); . &#55176;&#49828;&#53664;&#44536;&#47016; &#48143; Density Plots . 히스토그램과 KDE는 distplot을 사용하여 결합할 수 있습니다. . plt.figure(figsize=(10,10)) sns.distplot(data_BM[&#39;Item_Outlet_Sales&#39;]); . 4. Pair plots . 조인트 플롯을 더 큰 차원의 데이터세트로 일반화하면 페어 플롯으로 끝납니다. 이것은 모든 값 쌍을 서로에 대해 플롯하려는 경우 다차원 데이터 간의 상관 관계를 탐색하는 데 매우 유용합니다. . | 세 가지 붓꽃 종의 꽃잎과 꽃받침 측정값을 나열하는 잘 알려진 Iris 데이터 세트를 사용하여 이것을 시연할 것입니다. . | . iris = sns.load_dataset(&quot;iris&quot;) iris.head() . sepal_length sepal_width petal_length petal_width species . 0 5.1 | 3.5 | 1.4 | 0.2 | setosa | . 1 4.9 | 3.0 | 1.4 | 0.2 | setosa | . 2 4.7 | 3.2 | 1.3 | 0.2 | setosa | . 3 4.6 | 3.1 | 1.5 | 0.2 | setosa | . 4 5.0 | 3.6 | 1.4 | 0.2 | setosa | . sns.pairplot(iris, hue=&#39;species&#39;, height=2.5); # hue는 color . seaborn with matplotlib . 1.1 Load data . 예제로 사용할 펭귄 데이터를 불러옵니다 | seaborn에 내장되어 있습니다. | . import pandas as pd import matplotlib.pyplot as plt import seaborn as sns penguins = sns.load_dataset(&quot;penguins&quot;) penguins.head() . species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex . 0 Adelie | Torgersen | 39.1 | 18.7 | 181.0 | 3750.0 | Male | . 1 Adelie | Torgersen | 39.5 | 17.4 | 186.0 | 3800.0 | Female | . 2 Adelie | Torgersen | 40.3 | 18.0 | 195.0 | 3250.0 | Female | . 3 Adelie | Torgersen | NaN | NaN | NaN | NaN | NaN | . 4 Adelie | Torgersen | 36.7 | 19.3 | 193.0 | 3450.0 | Female | . 1.2 Figure and Axes . matplotlib으로 도화지figure를 깔고 축공간axes를 만듭니다. | 1 x 2 축공간을 구성합니다. | . fig, axes = plt.subplots(ncols=2, figsize=(8,4)) fig.tight_layout() . 1.3 plot with matplotlib . matplotlib 기능을 이용해서 산점도를 그립니다. | x축은 부리 길이 bill length | y축은 부리 위 아래 두께 bill depth | 색상은 종species로 합니다. | Adelie, Chinstrap, Gentoo이 있습니다. | 두 축공간 중 왼쪽에만 그립니다. | 컬러를 다르게 주기 위해 f-string 포맷을 사용했습니다. | f-string 포맷에 대한 설명은 https://blockdmask.tistory.com/429를 참고하세요 | . fig, axes = plt.subplots(ncols=2,figsize=(8,4)) species_u = penguins[&quot;species&quot;].unique() for i, s in enumerate(species_u): axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C{i}&quot;, label=s, alpha=0.3) axes[0].legend(species_u, title=&quot;species&quot;) axes[0].set_xlabel(&quot;Bill Length (mm)&quot;) axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;) # plt.show() fig.tight_layout() . 조금 더 간단히 그리는 방법 matplotlib는 기본적으로 Categorical 변수를 color로 바로 사용하지 못함 . penguins[&quot;species_codes&quot;] = pd.Categorical(penguins[&quot;species&quot;]).codes fig, axes = plt.subplots(ncols=2,figsize=(8,4)) axes[0].scatter(data=penguins, x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, c=&quot;species_codes&quot;, alpha=0.3) . &lt;matplotlib.collections.PathCollection at 0x1ee029ed820&gt; . 1.4 Plot with seaborn . fig, axes = plt.subplots(ncols=2,figsize=(8,4)) species_u = penguins[&quot;species&quot;].unique() # plot 0 : matplotlib for i, s in enumerate(species_u): axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C{i}&quot;, label=s, alpha=0.3) axes[0].legend(species_u, title=&quot;species&quot;) axes[0].set_xlabel(&quot;Bill Length (mm)&quot;) axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;) # plot 1 : seaborn sns.scatterplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1]) axes[1].set_xlabel(&quot;Bill Length (mm)&quot;) axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;) fig.tight_layout() . 단 세 줄로 거의 동일한 그림이 나왔습니다. | scatter plot의 점 크기만 살짝 작습니다. | label의 투명도만 살짝 다릅니다. | seaborn 명령 scatterplot()을 그대로 사용했습니다. | x축과 y축 label도 바꾸었습니다. | ax=axes[1] 인자에서 볼 수 있듯, 존재하는 axes에 그림만 얹었습니다. | matplotlib 틀 + seaborn 그림 이므로, matplotlib 명령이 모두 통합니다. | . 1.5 matplotlib + seaborn &amp; seaborn + matplotlib . matplotlib과 seaborn이 자유롭게 섞일 수 있습니다. | matplotlib 산점도 위에 seaborn 추세선을 얹을 수 있고, | seaborn 산점도 위에 matplotlib 중심점을 얹을 수 있습니다. | 파이썬 코드는 다음과 같습니다. | . fig, axes = plt.subplots(ncols=2, figsize=(8, 4)) species_u = penguins[&quot;species&quot;].unique() # plot 0 : matplotlib + seaborn for i, s in enumerate(species_u): # matplotlib 산점도 axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C{i}&quot;, label=s, alpha=0.3 ) # seaborn 추세선 sns.regplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, data=penguins.loc[penguins[&quot;species&quot;]==s], scatter=False, ax=axes[0]) axes[0].legend(species_u, title=&quot;species&quot;) axes[0].set_xlabel(&quot;Bill Length (mm)&quot;) axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;) # plot 1 : seaborn + matplotlib # seaborn 산점도 sns.scatterplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1]) axes[1].set_xlabel(&quot;Bill Length (mm)&quot;) axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;) for i, s in enumerate(species_u): # matplotlib 중심점 axes[1].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), c=f&quot;C{i}&quot;, alpha=1, marker=&quot;x&quot;, s=100 ) fig.tight_layout() . 1.6 seaborn + seaborn + matplotlib . 안 될 이유가 없습니다. | seaborn scatterplot + seaborn kdeplot + matplotlib text입니다 | . fig, ax = plt.subplots(figsize=(6,5)) # plot 0: scatter plot sns.scatterplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, color=&quot;k&quot;, data=penguins, alpha=0.3, ax=ax, legend=False) # plot 1: kde plot sns.kdeplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.5, ax=ax, legend=False) # text: species_u = penguins[&quot;species&quot;].unique() for i, s in enumerate(species_u): ax.text(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), s = s, fontdict={&quot;fontsize&quot;:14, &quot;fontweight&quot;:&quot;bold&quot;,&quot;color&quot;:&quot;k&quot;} ) ax.set_xlabel(&quot;Bill Length (mm)&quot;) ax.set_ylabel(&quot;Bill Depth (mm)&quot;) fig.tight_layout() .",
            "url": "https://kangsuin01.github.io/suin_blog/2022/05/13/matplotlib-seaborn-kangsuin.html",
            "relUrl": "/2022/05/13/matplotlib-seaborn-kangsuin.html",
            "date": " • May 13, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Python basics",
            "content": "python basics . # if x &lt; pivot: # less.append(x) # else: # greater.append(x) . &#54632;&#49688; &#48143; &#44060;&#52404; &#47700;&#49436;&#46300; &#54840;&#52636; . # g() # obj.some_method(x,y,z) # result = f(a,b,c,d=5,e = &#39;foo&#39;) . &#48320;&#49688; &#48143; &#51064;&#49688; &#51204;&#45804; . a = [1,2,3] . b = a . a.append(4) b . [1, 2, 3, 4] . def append_element(some_list, element): some_list.append(element) data = [1,2,3] append_element(data,4) data . [1, 2, 3, 4] . type&#44288;&#47144; . a = 5 type(a) . int . a = &#39;foo&#39; type(a) . str . &#39;5&#39;+5 # 문자와 숫자는 연산할 수 없음 . TypeError Traceback (most recent call last) &lt;ipython-input-9-aefad37e75d9&gt; in &lt;module&gt; -&gt; 1 &#39;5&#39;+5 # 문자와 숫자는 연산할 수 없음 TypeError: can only concatenate str (not &#34;int&#34;) to str . a = 4.5 b = 2 #String formatting, to be visited later print(&#39;a is {0}, b is {1}&#39;.format(type(a),type(b))) a/b . a is &lt;class &#39;float&#39;&gt;, b is &lt;class &#39;int&#39;&gt; . 2.25 . a = 5 isinstance(a, int) . True . a = 5; b = 4.5 isinstance(a, (int, float)) isinstance(b, (int, float)) . True . &#49549;&#49457; &#48143; &#47700;&#49548;&#46300; . -파이썬의 객체는 일반적으로 속성(객체 &quot;내부&quot;에 저장된 다른 파이썬 객체)과 메소드(객체의 내부 데이터에 액세스할 수 있는 객체와 관련된 함수)를 모두 가지고 있습니다. 둘 다 obj.attribute_name구문을 통해 액세스됩니다 . a = &#39;foo&#39; . . a.upper() . &#39;FOO&#39; . &#49549;&#49457; &#48143; &#47700;&#49436;&#46300;&#45716; getattr &#54632;&#49688;&#47484; &#53685;&#54644; &#51060;&#47492;&#51004;&#47196; &#50529;&#49464;&#49828;&#54624; &#49688;&#46020; &#51080;&#49845;&#45768;&#45796; . getattr(a, &#39;split&#39;) . &lt;function str.split(sep=None, maxsplit=-1)&gt; . Duck typing . def isiterable(obj): try: iter(obj) return True except TypeError: # 반복 가능하지 않다 return False . isiterable(&#39;a string&#39;) . True . isiterable([1,2,3]) . True . isiterable(5) . False . module&#47564;&#46308;&#44592; . 원주율 이용해서 some_module만들기 | module을 만들 때는 jupyter에서 new클릭 후 text파일을 열어서 확장자를 py로 저장 | . PI = 3.14159 def f(x): return x+2 def g(a,b): return a+b . 같은 디렉토리에 있는 다른 곳에서 some_module.py에 정의된 변수와 함수에 액세스 하려면 다음을 수행할 수 있다. . import some_module result = some_module.f(5) result . 7 . pi = some_module.PI pi . 3.14159 . from some_module import f,g,PI result = g(5,PI) result . 8.14159 . &#51060;&#54637; &#50672;&#49328;&#51088; &#48143; &#48708;&#44368; . a = [1,2,3] b =a c = list(a) a is b . True . a is not c . True . list는 항상 새로운 python list(복사본)를 생성하므로 c가 와 구별된다는 것을 알 수 있다. &#39;is&#39;와 비교하는 것은 &#39;==&#39; 연산자와 같지 않다. 밑을 참고 . a == c . False . a = None a is None . True . &#48320;&#44221; &#44032;&#45733;&#54620; &#44061;&#52404;&#50752; &#48320;&#44221; &#48520;&#44032;&#45733;&#54620; &#44061;&#52404; . list, dictionary, Numpy array 및 대부분의 사용자 정의 유형(클래스)과 같은 python의 대부분의 객체는 변경할 수 있다. 이는 포함된 개체 또는 값을 수정할 수 있음을 의미 . a_list = [&#39;foo&#39;,2,[4,5]] a_list[2] a_list . [&#39;foo&#39;, 2, [4, 5]] . 문자열 및 튜플과 같은 기타항목은 변경할 수 없다. . a_tuple = (3,5,(4,5)) a_tuple[1] = &#39;four&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-32-1990528cab52&gt; in &lt;module&gt; 1 a_tuple = (3,5,(4,5)) -&gt; 2 a_tuple[1] = &#39;four&#39; TypeError: &#39;tuple&#39; object does not support item assignment . &#49828;&#52860;&#46972; &#50976;&#54805; . 숫자 파이썬에서 숫자 기본 유형은 int와 float이며 int는 임의로 큰 숫자를 저장할 수 있음 . ival = 17239871 ival ** 6 . 26254519291092456596965462913230729701102721 . 3/2 . 1.5 . type(3/2) . float . type(3//2) . int . &#47928;&#51088;&#50676; . &#39;&#39; | &quot;&quot; | &#39;&#39;&#39;&#39;&#39;&#39; | &quot;&quot;&quot;&quot;&quot;&quot; | . c = &quot;&quot;&quot; This is a longer string that spans multiple lines &quot;&quot;&quot; . c . &#39; nThis is a longer string that nspans multiple lines n&#39; . c.count(&quot; n&quot;) # c의 n 개수 세기 . 3 . a = &#39;this is a string&#39; a[10] = &#39;f&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-42-21ee4aca937c&gt; in &lt;module&gt; 1 # 문자열을 수정할 수 없음 2 a = &#39;this is a string&#39; -&gt; 3 a[10] = &#39;f&#39; TypeError: &#39;str&#39; object does not support item assignment . b = a.replace(&#39;string&#39;,&#39;longer string&#39;) # a의 string을 longer string으로 바꾸기 b . &#39;this is a longer string&#39; . a . &#39;this is a string&#39; . str함수를 사용하여 많은 파이썬 객체를 문자열로 변환할 수 있습니다. . a = 5.6 s = str(a) print(s) . 5.6 . 문자열은 유니코드 문자의 시퀀스이므로 list 및 튜플과 같은 다른 시퀀스처럼 처리될 수 있다. . s = &#39;python&#39; list(s) . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . s[:3] . &#39;pyt&#39; . s[:3]은 슬라이싱이라고 하며 많은 종류의 파이썬 시퀀스에 대해 구현된다. 백슬래시 문자()는 이스케이프 문자로 유니코드 문자와 같은 특수 문자를 지정하는데 사용된다. 백슬래시가 있는 문자열 리터럴을 작성하려면 백슬래시를 이스케이프해야한다. . print(&#39;12 n34&#39;) . 12 34 . s = &#39;12//34&#39; print(s) . 12//34 . 두 문자열을 함께 추가하면 두 문자열이 연결되어 새 문자열이 생성된다. . a = &#39;this is the first half&#39; b = &#39;and this is the second half&#39; a+b . &#39;this is the first halfand this is the second half&#39; . 문자열 포메팅 문자열 객체에는 형식이 지정된 인수를 문자열로 대체하여 새 문자열을 생성하는데 사용할 수 있는 대체에 사용할 수 있는 형식 메서드가 있다. 문자열 객체에는 형식이 지정된 인수를 문자열로 대체하여 새 문자열을 생성하는 데 사용할 수 있는 대체에 사용할 수 있는 형식 메서드가 있다. . template = &#39;{0:2f}{1:s} are worth US${2:d}&#39; template . &#39;{0:2f}{1:s} are worth US${2:d}&#39; . {0:f}는 첫번째 인수의 형식을 소수점 2자리 부동 소수점 숫자로 지정하는 것을 의미 | {1:s}는 두 번째 인수의 형식을 문자열로 지정 | {2:d}는 세 번째 인수의 형식을 정확한 정수로 지정하는 것을 의미 | . template.format(4.5560,&#39;Argentine Pesos&#39;, 1) . &#39;4.556000Argentine Pesos are worth US$1&#39; . template.format(1263.23, &#39;won&#39;, 1) . &#39;1263.230000won are worth US$1&#39; . Booleans . python의 2개의 부울 값은 TRUE값과 FALSE로 작성한다. 비교및 기타 조건 식은 True 또는 False로 평가된다. 부울 값은 and와 or키워드와 조합된다. . True and True . True . False or True . True . Type casting . str, bool, int, float 타입도 값을 캐스팅하는데 사용할 수 있는 함수다. . s = &#39;3.14159&#39; fval = float(s) type(fval) . float . int(fval) . 3 . bool(fval) . True . bool(0) . False . None . None은 python null값 유형이다. 함수가 명시적으로 값을 반환하지 않으면 암묵적으로 None을 반환합니다. . a = None a is None . True . b = 5 b is not None . True . none은 함수 인수의 일반적인 기본값이기도 함 . def add_and_maybe_multiply(a,b,c=None): result = a+b if c is not None: result = result * c return result . add_and_maybe_multiply(5,3) . 8 . add_and_maybe_multiply(5,3,10) . 80 . &#45936;&#51060;&#53552;&#50752; &#49884;&#44036; . 내장된 python datetime 모듈은 datetime, 날짜 및 시간 유형을 제공한다. datetime유형은 예상대로 날짜와 시간에 저장된 정보를 조합하여 가장 일반적으로 사용된다. . from datetime import datetime, date, time dt = datetime(2011,10,29,20,30,21) dt . datetime.datetime(2011, 10, 29, 20, 30, 21) . dt.day . 29 . dt.minute . 30 . 지정된 datetime 인스턴스에서 동일한 이름의 datetime 메서드를 호출하여 동일한 날짜 및 시간 개체를 추출할 수 있다. . dt.date() . datetime.date(2011, 10, 29) . dt.time() . datetime.time(20, 30, 21) . strftime메서드는 datetime을 문자열로 포맷한다. . dt.strftime(&#39;%m/%d/%Y %H:%M&#39;) . &#39;10/29/2011 20:30&#39; . dt.strftime(&#39;%Y/%m/%d %H:%M&#39;) . &#39;2011/10/29 20:30&#39; . strptime 함수를 사용하여 문자열을 datetime 개체로 변환할 수 있다. . datetime.strptime(&#39;20091031&#39;, &#39;%Y%m%d&#39;) . datetime.datetime(2009, 10, 31, 0, 0) . 시계열 데이터를 집계하거나 그룹화할 때, 예를 들어 분, 초를 0으로 바꾸는 등 일련의 데이터 시간 필드를 바꾸는 것이 유용할 수 있다. . dt.replace(minute=0,second=0) . datetime.datetime(2011, 10, 29, 20, 0) . dt2 = datetime(2011,11,15,22,30) delta = dt2-dt delta . datetime.timedelta(days=17, seconds=7179) . type(delta) . datetime.timedelta . dt dt+delta . datetime.datetime(2011, 11, 15, 22, 30) . control Flow(&#55120;&#47492;&#51228;&#50612;) . python에는 다른 프로그래밍 언어에서 볼 수 있는 조건부 논리, 루프 및 기타 표준 제어 흐름 개념에 대한 몇 가지 키워드가 내장되어 있습다. if, elif, other if문은 가장 잘 알려진 제어문 중 하나이다. True일 경우 다음 볼록의 코드를 평가하는 조건을 체크한다. . x = -5 if x&lt;0: print(&#39;It is negative&#39;) . It is negative . 모든 조건이 False일 경우 if 문 뒤에 하나 이상의 elif 블록과 catch all other블록을 선택적으로 사용할 수 있다. . x = -5 if x&lt;0: print(&#39;It is negative&#39;) elif x == 0: print(&#39;Equal to zero&#39;) elif 0&lt;x&lt;5: print(&#39;Positive but smaller than 5&#39;) else: print(&#39;Positive and larger than or equal to 5&#39;) . It is negative . 어느 하나의 조건의 True일 경우 더이상의 elif 또는 다른 블록에 도달하지 않는다. and나 or을 사용하는 복합 조건의 경우 조건은 왼쪽에서 오른쪽으로 평가되며 단락된다. . a = 5; b=7 c=8; d=4 if a&lt;b or c&gt;d: print(&#39;Made it&#39;) . Made it . 이 예에서는 첫번째 비교가 True였기 때문에 c&gt;d의 비교는 평가되지 않는다. 연쇄비교도 가능하다. . 4&gt;3&gt;2&gt;1 . True . 3&gt;5 or 2&gt;1 . True . 3&gt;5&gt;2&gt;1 . False . for loops . 루프는 컬렉션(리스트나 튜플 등) 또는 반복문으로 반복하기 위한 것이다. for 루프의 표준구문은 아래와 같다. for value in collection: # do something with value continue 키워드를 사용하면 for루프를 다음 반복으로 진행하여 블록의 나머지 부분을 건너뛸 수 있다. list의 정수를 집계하고 None값을 건너뛴다. . sequence = [1,2,None, 4, None, 5] total = 0 for value in sequence: total+=value . TypeError Traceback (most recent call last) &lt;ipython-input-48-6f47744c1319&gt; in &lt;module&gt; 3 4 for value in sequence: -&gt; 5 total+=value TypeError: unsupported operand type(s) for +=: &#39;int&#39; and &#39;NoneType&#39; . sequence = [1,2,None,4,None,5] total = 0 for value in sequence: if value is None: continue total +=value . total . 12 . for루프는 break키워드를 사용하여 모두 종료할 수 있다. 이 코드는 5에 도달할 때까지 list의 요소를 합산한다. . sequence = [1,2,0,4,6,5,2,1] total_until_5 = 0 for value in sequence: if value == 5: break total_until_5 += value . total_until_5 . 13 . break키워드는 가장 안쪽의 for루프만 종료한다. 루프 바깥쪽은 계속 실행된다. . for i in range(4): for j in range(4): if j&gt;i: break print((i,j)) . (0, 0) (1, 0) (1, 1) (2, 0) (2, 1) (2, 2) (3, 0) (3, 1) (3, 2) (3, 3) . 자세한 내용은 컬렉션 또는 반복문 내의 요소가 시퀀스(튜플 또는 리스트 등)인 경우 쉽게 for loop상태의 변수로 압축해제할 수 있다. for a,b,c in iterator: # do something . for a,b,c in [[1,2,3],[4,5,6],[7,8,9]]: print(a,b,c) . 1 2 3 4 5 6 7 8 9 . while loops . while loop는 조건과 조건이 False로 평가되거나 루프가 명시적으로 break로 종료할 때까지 실행되는 코드 븍록을 지정한다. . x = 256 total = 0 while x&gt;0: if total&gt;500: break total += x x = x//2 . total . 504 . x . 4 . 256+128+64+32+16+8 . 504 . pass . pass는 python에서 &quot;no-op&quot;(No Operation) 상태이다. 이는 액션이 수행되지 않는 블록(또는 아직 구현되지 않은 코드의자리 표시자)에서 사용할 수 있다. python은 블록을 구분하기 위해서 공백공간을 사용하기 때문에 들여쓰기가 필요함 . x = -1 if x&lt;0: print(&#39;negative!&#39;) elif x == 0: #TODO: put something smart here pass else: print(&#39;positive&#39;) . negative! . range함수는 균일한 간격의 정수 시퀀스를 생성하는 반복문을 반환한다 . range(10) . range(0, 10) . list(range(10)) . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . 시작, 종료 및 단계(음수일 수 있음)를 모두 지정할 수 있다. . list(range(0,20,2)) . [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] . list(range(5,0,-1)) . [5, 4, 3, 2, 1] . 위와 같이 범위를 지정하면 끝점을 포함하지 않는 정수가 생성된다. 범위를 일반적으로 사용하면 인덱스로 시퀀스를 반복할 수 있다. . seq = [1,2,3,4] for i in range(len(seq)): val = seq[i] . val . 4 . list와 같은 함수를 사용하여 범위별로 생성된 모든 정수를 다른 데이터구조에 저장할 수 있지만 종종 기본 반복문 형식이 된다. 여기서는 3 또는 5의 배수인 0~99999의 모든 수치를 집계하고 있다. . sum = 0 for i in range(100000): # % is the modulo operator if i % 3 == 0 or i % 5 == 0: sum += i . Ternary expressions . value = true-expr if condition else false-expr 여기서 true-expr 및 false-expr은 임의의 python식입니다. if condition: value = true-expr else: value = false-expr . x=5 &#39;Non-negative&#39; if x&gt;= 0 else &#39;Negative&#39; . &#39;Non-negative&#39; . x = 5 a = 100 if x&gt;=0 else -100 a . 100 .",
            "url": "https://kangsuin01.github.io/suin_blog/jupyter/python/2022/03/21/python-basics.html",
            "relUrl": "/jupyter/python/2022/03/21/python-basics.html",
            "date": " • Mar 21, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "Markdown Cheat Sheet",
            "content": "Markdown Cheat Sheet . Thanks for visiting The Markdown Guide! . This Markdown cheat sheet provides a quick overview of all the Markdown syntax elements. It can’t cover every edge case, so if you need more information about any of these elements, refer to the reference guides for basic syntax and extended syntax. . Basic Syntax . These are the elements outlined in John Gruber’s original design document. All Markdown applications support these elements. . Heading . H1 . H2 . H3 . Bold . bold text . Italic . italicized text . Blockquote . blockquote . Ordered List . First item | Second item | Third item | Unordered List . First item | Second item | Third item | . Code . code . Horizontal Rule . . Link . Markdown Guide . Image . . Extended Syntax . These elements extend the basic syntax by adding additional features. Not all Markdown applications support these elements. . Table . Syntax Description . Header | Title | . Paragraph | Text | . Fenced Code Block . { &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25 } . Footnote . Here’s a sentence with a footnote. 1 . Heading ID . My Great Heading . Definition List . term definition Strikethrough . The world is flat. . Task List . Write the press release | Update the website | Contact the media | . Emoji . That is so funny! :joy: . (See also Copying and Pasting Emoji) . Highlight . I need to highlight these ==very important words==. . Subscript . H~2~O . Superscript . X^2^ . This is the footnote. &#8617; . |",
            "url": "https://kangsuin01.github.io/suin_blog/markdown/2022/03/11/markdown-cheat-sheet.html",
            "relUrl": "/markdown/2022/03/11/markdown-cheat-sheet.html",
            "date": " • Mar 11, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://kangsuin01.github.io/suin_blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://kangsuin01.github.io/suin_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "About me . 안녕하세요. 강수인입니다. .",
          "url": "https://kangsuin01.github.io/suin_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://kangsuin01.github.io/suin_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}